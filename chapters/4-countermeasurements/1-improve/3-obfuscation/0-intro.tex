man versucht sich vor neuen angriffen zu schützen indem man reengineering zeitintensiver macht


wenn anderes zb nicht geht weil algorithmus in der app, ohne redesign, wenn man auf kapiutel 1 sitzen bleibt, kein kontent server möglich, smartcard nicht einbauen will weil extra hardware/kosten,...

ref kapitel 1 macht gg lucky sicher, aber crakcbar wenn manuell, was kann man dagegen tun



now that the lvl is modified and the environment is enforced, the next goal is to prevent pirates from even starting to analyze the applcation, automatischer crack nicht mehr funktioniert, muster, andere mechanismen erkennt er nicht

does not help when standard version is implemented, that is why this is working best with customized implementation of LVL
%
Reverse engineering and code protection are processes which are opposing each other, neither classified as good nor bad\newline
"good" developer: malware detection and IP protection\newline
"bad" developer: analysis for attack and analysis resistance

\cite{kovachevaMaster}
%
it is not possible to 100 percent evade reengineering, but adding different methods to hide from plain sight of reengineering tools
%
reengineering cannot be vermiede
best is to apply technqiues to make it as hard a possible
\cite{munteanLicense}
%

if they do not see what the app is doing, they cannot fix it

Application developers are interested in protecting their applications. Protection in this case means that it should be hard to understand
what an application is doing and how its functionalities are implemented.\newline


Reverse engineering of Android applications is much easier than on other architectures -see- high level but simple bytecode language\newline

Obfuscation techniques protect intellectual property of software/license verification\newline

possible code obfuscation methods on the Android platform focus on obfuscating Dalvik bytecode -see- limitations of current reverse engineering tools\newline

%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT
SOLUTION
obfuscators are applied when compiling

%
(a) at source code and (b) bytecode level, Most existing open-source and commercial tools work on source code level\newline
Java code is architecture-independent giving freedom to design generic code transformations. Lowering the obfuscation level to bytecode requires the algorithms applied to be tuned accordingly to the underlying architecture\newline
\cite{kovachevaMaster}
%

%
a few dex obfuscators exist, with different approaches
proguard or sdex, rename methods, field and calss names -- break down string operations so as to chop hard coded strings or encrypt -- can use dynamic class loading (dexloader classes to impede static analysis)
can add dead code and dummy lopps (minor impact of performance)
can also use goto into other onstructions

\cite{andevconDalvikART}
%


%

layout obfuscation
most programmers name their variables, methods and calss in meaning ful way
are preserved in generation of bytecode for dvm, hence still in dex, can be extracted by attacker, gain information and benefit when reengineering
mangles names and ifentifiers that original meaning is lost while preserving correctness of syntax and semantics
result is bytecode can be interpreted but dissable and decompiule provide meaningless name for identifiers etc, e.g single letters or short combinations, welcome for strings section make it smaller
only complicates but does not stop


\cite{munteanLicense}
%

%
first line of defense, can be applied without much extra workload
will not protect against autoamted attack, does not alter flow of program
makes more difficult for attackers to write initial attack
removing symbols that would quickly reveal original structure
number of commercial and open-source obfuscators available for Java that will work with Android

be aware that certain methods cannot be obfuscated, even with advanced tools
e.g. on create cannot be renamed since it needs to remain callable by the android system
avoid putting license check code in these methods since attackers will be looking for the lvl there
\cite{developersSecuring}
%


Without proper naming of classes and methods it is much harder to reverse engineer an application, because in most cases the identifier enables an analyst to directly guess the purpose of the particular part. The program code itself will not be changed heavily, so the obfuscation by this tool is very limited.

hilft nicht direkt, aber um reengineering besser zu machen
does not protect directly versus luckypatcher but in case of an custom implementation it makes the process of analyzing the app more time consuming

definition obfuscation, was macht es, wie funktioniert es, wer hat es erfunden, wie wendet man es an\newline

"hard to reverse engineer" but without changing the behavior of this
application, was heißt hard to reverse\newline

parallele zu disassembler ziehen\newline

Obfuscation cannot prevent reverse engineering but can make it harder and more time consuming. We will discuss which obfuscation and code protection methods are applicable under Android and show limitations of current reverse engineering tools\newline

The following optimizers/obfuscators are common tools. (dadrin dann verbreitung preis etc erklären)





angriff beschreiben
- library öffentlich
- reengineering (ref meien tools)

davor schützen, jeden beliebigen test durch unäre antwort ersetzen, um das zu umgehen höher level als die license verifcation

=> tests die man auf unär modifizieren kann sind schwerer zu lokalisieren, hilft gg reengineering



%eval
in theory a good addition to the security of the application, but against luckypatcher directly since it works on java level in order to disguise the way the code works
it enforces increased initial effort an attacker has to spend in order to understand the code and thus reduces the likelihood of attackers to being motivated to crack the application
in practice obfuscators are limited due to:
reliance on android framework apis (remain unobfuscated)
applications can be debugged
jdwp and application debuggability at the java lvl can reveal information about the software
popular enough obfuscators (dexguard) have deobfuscators
professional tools cost a lot of money, you have to be commercial or have a real good idea in order to be worthwhile
