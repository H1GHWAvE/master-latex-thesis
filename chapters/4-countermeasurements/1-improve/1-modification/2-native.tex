\subsubsection{Native Implementation} \label{subsection:counter-modifications-dynamic}

Lucky Patcher's automatic patching modes, as described in chapter~\ref{chapter:luckypatcher}m target the application's \gls{dex} file.
In order to  thus removing it from this file makes it more complicated to crack the application sucessfully.
Since Android supports the \gls{ndk}, it is possible to implement parts of the application using native code.
Usually the \gls{ndk} targets CPU intensive taks, such as game engines and signal processing, but it can be used for any other purposes as well.
Google suggests using it only if necessary since it increases the complexity of an application, which, in case of the license verification library, is desired \cite{androidNdk}.



there are two scenarios:
first scenario
developers creates his own version of native implementation
unique, but developer has to create it itself, knowledge and skill is needed and time has to be spent
if done right, safe and advantage that the attacker has to invest time for this app itself in order to analyze the native code, then find a method to break it and repack it and make it available as custom patch, scares off attackers since a lot of work, have to evaluate whether app is worth it
so if the resources are available, best method

second scenario
one public native library provided by google
but when all use the same library, it is a vulnerable point because it makes sense for attackers to analyze the library and try to come up with a patch, since one solution can be applied to many different apps which would justify a lot of work as described in the first scenario, this patch then can then be applied as a custom patch via luckypatcher

for this reason when coming up with a native implementation for a library for all, two things should be included
- users do not custimize library so a heavy obfuscation should be applied
- since there is only one version, make it as hard to reengineer and predictable as possible, use encryption and dynamic code generation, automatically custimize itself for every app and ever time its loaded
this needs a lot of research, work and if it would be so simple, big companies like google would already have come up with it, but in this direction it has to go when stick around for a long time with dex and its vulnerabilities


this way luckypatcher has to create a custom recipe for your application since custom recipes can inject .so files
at first a good protection against luckypatcher since the automatic patching discussed in does not work for the app any longer, but not protection of luckypatcher because it supports custom patching
when analyzing luckypatcher there can be .so files be found which are used to replace existing ones in order to patch fucntionality

so now attackers have to invest time in analyzing the native code
difficult since in opposite of byte-code, it does not contain a lot of meta-data such as local variable types, class strcture, which allows bytecode to be compiled on multiple devices, this information is discarded in native code in the compilation process

%EVAL
elemente für app in native initiieren, damit man nicht einfach deaktivieren kann
nur gut wenn wichtige funktionen der app enthält
native code is difficult to be decompiled, can be checked for tampering when loading it
