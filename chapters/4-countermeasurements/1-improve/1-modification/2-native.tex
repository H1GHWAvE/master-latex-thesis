\subsubsection{Native Implementation} \label{subsubsection:counter-modifications-dynamic}
%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT

luckypatcher automatic patching works on dex, why not remove the key license verification code from from java and move it to native code, this way luckypatcher has to create a custom recipe for your application since custom recipes can inject .so files

native code can be executed using two thinks, android ndk a toolset to implement native-code languages, e.g. c or c++, and  \gls{jni} used by java to execute native code

native code is difficult to be decompiled, can be checked for tampering when loading it

%EVAL
elemente für app in native initiieren, damit man nicht einfach deaktivieren kann

nur gut wenn wichtige funktionen der app enthält



%eval
at first a good protection against luckypatcher since the automatic patching discussed in chapter~\ref{chapter:luckypatcher} does not work for the app any longer, but not protection of luckypatcher because it supports custom patching
when analyzing luckypatcher there can be .so files be found which are used to replace existing ones in order to patch fucntionality

so now attackers have to invest time in analyzing the native code
difficult since in opposite of byte-code, it does not contain a lot of meta-data such as local variable types, class strcture, which allows bytecode to be compiled on multiple devices, this information is discarded in native code in the compilation process

there are two scenarios:
first scenario
developers creates his own version of native implementation
unique, but developer has to create it itself, knowledge and skill is needed and time has to be spent
if done right, safe and advantage that the attacker has to invest time for this app itself in order to analyze the native code, then find a method to break it and repack it and make it available as custom patch, scares off attackers since a lot of work, have to evaluate whether app is worth it
so if the resources are available, best method

second scenario
one public native library provided by google
but when all use the same library, it is a vulnerable point because it makes sense for attackers to analyze the library and try to come up with a patch, since one solution can be applied to many different apps which would justify a lot of work as described in the first scenario, this patch then can then be applied as a custom patch via luckypatcher

for this reason when coming up with a native implementation for a library for all, two things should be included
- users do not custimize library so a heavy obfuscation should be applied
- since there is only one version, make it as hard to reengineer and predictable as possible, use encryption and dynamic code generation, automatically custimize itself for every app and ever time its loaded
this needs a lot of research, work and if it would be so simple, big companies like google would already have come up with it, but in this direction it has to go when stick around for a long time with dex and its vulnerabilities
