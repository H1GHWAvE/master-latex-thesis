\section{Patch Patterns} \label{section:luckypatcher-patterns}
In order to identify the changes done by each individual \textit{Patch Pattern}, the code of the original and cracked \gls{apk} are compared.
The changes are inspected on dex, smali and Java level with the tools explained in section~\ref{section:reengineering}.
\newline
The names \gls{luckypatcherg} assigns to the \textit{Patch Patterns} and Patches are taken from the patching result output in figure~\ref{fig:luckyScreen} on the right.
While \gls{luckypatcherg} provides seven different patterns for the \gls{lvl}, called \textit{Patch Pattern N1..N7}, it gives to Amazon and Samsung one patch each and calls them \textit{Amazon Market Patch} and \textit{SamsungApps Patch}, respectively.
\newline
When patching the \gls{lvl}, \gls{luckypatcherg}'s choice of patterns is dependent on the selected modus.
Table~\ref{table:patterns} gives an overview based on the black box test.
It shows the patching modes and the \textit{Patch Patterns} or \textit{Patches} applied.
\newline
\begin{table}[h]
\centering
\begin{tabular}{l|cccccccccc}
              & \multicolumn{10}{c}{Patch Patterns}      \\
\multicolumn{1}{c|}{Modus} & N1 & N2 & N3 & N3i & N4 & N5 & N6 & N7 & A & S \\ \hline
Auto            & X & X & X &   & X &  &  & && \\
Auto (Inversed)      & X & X &  & X  & X &  &  & && \\
Extreme          &  &  &  &   &  & X & X & X && \\
Auto+Extreme        & X & X & X &   & X & X & X & X && \\
Auto (Inversed)+Extreme  & X & X &  & X  & X & X & X &X &&\\
Amazon        &  & X&  &   &  &  &  & &X&\\
Samsung        &  &  X&  &   &  &  &  &  &&X
\end{tabular}
\caption{Overview of \textit{Patch Patterns}/\textit{Patches} applied by each mode}
\label{table:patterns}
\end{table}
As shown in the following, the changes observed in the black box test are only replacements of bytecode and very limited in scope and number.
They do not add or remove bytecode, i.e. they do not add or remove logic blocks.
Instead \gls{luckypatcherg} enforces a certain control flow, by forcing an evaluation to be \textit{true} or \textit{false} as needed and ignoring actual results of method calls.
This is done by manipulating a single instruction, either opcode or argument.
The surrounding context remains untouched.
\newline
All this is done on the dex bytecode level, which opens the question on how the target to be changed is located.
As will be shown, \gls{luckypatcherg} uses bytecode search patterns to locate where the change should be placed and bytecode replace pattern to execute it.
\newline
The search pattern consists of the target instruction to be manipulated and the context, while the replace pattern has the same context with the target instruction changed.
A look at the \gls{luckypatcherg} sources shows that it contains strings, which are formatted like bytecode, include the target instructions and the context in a masked form.
These strings are located in the Java class \textit{com/chelpus/root/utils/odexrunpatch.java} and appear in the context of the \textit{Patch Pattern} they belong to.
Each \textit{Patch Pattern} can have multiple bytecode patterns, implementing the same change in different contexts, which are tried when the \textit{Patch Pattern} is used.
\newline
The context in a search pattern is given as a mask of a fixed length with fixpoints given as explicit bytecode tuples and placeholders.
When \gls{luckypatcherg} tries to position a search pattern, it searches for a sequence of bytecodes matching the fix points and the target instruction as given by the mask.
On success, it substitutes that sequence with the replace pattern.
\newline
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={65-69},
 caption={Bytecode patterns - Target instructions are colored in green and red, fixpoints in blue and placeholders given as ??},
 label={codeSnippet:example}
]{data/patterns.diff}
Before explaining the patterns in detail, additional information has to be provided.
In the \gls{dex} file analysis, a simplified presentation of the binary data as \textit{0a} instead of hexadecimal values like \textit{0x0a} is chosen for improved readability in the diff files.
When converting \gls{dex} files to smali files, arguments like \textit{x} in dex code are shown as  v\textit{x} in smali and constants stay the same.
The opcode defines which of its arguments are constants or variables
\newline
\newline
When the dex code of an application is modified, the checksum has to be recalculated and the file has to be signed again.
These changes can be seen in the diff of the dex files but not explicitly shown in this text.
They are required by Android to make the \gls{dex} file valid, but do not change the application logic.

\subsubsection{Patch Pattern N1}
\textit{Patch Pattern N1} is present in all patching modes, except the solo extreme mode.
It targets the \textit{verify()} method of the \textit{LicenseValidator} class in the \textit{com/google/android/vending/licensing/} folder.
This method is responsible for decrypting and verifying the response from the license server \cite{developersLicensingReference}.
\newline
The \textit{Patch Pattern} swaps \textit{1a} and \textit{0f} in their order, as seen in the dex code in code snippet~\ref{codeSnippet:n1DiffDex}.
\newline
No matching bytecode pattern for \textit{Patch Pattern N1} is identified in the source code analysis of \gls{luckypatcherg}, neither by name nor by verification.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-3},
 caption={ Diff on dex level for \textit{Patch Pattern N1}},
 label={codeSnippet:n1DiffDex}
]{data/n1.diff}
When looking at the smali code, the two switched bytecode tuples can be identified as blocks of a switch statement.
Note that due to the internal mapping by the language, variables have different names.
The swap of switch cases \textit{0x1} und \textit{0x2} can be seen in the diff of code snippet~\ref{codeSnippet:n1DiffSmali}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={5-9},
 caption={Diff on Smali level for \textit{Patch Pattern N1}},
 label={codeSnippet:n1DiffSmali}
]{data/n1.diff}
In the Java code snippet~\ref{codeSnippet:n1DiffJava}, the changes can be seen in their context.
Before the patch, \textit{LICENSED} and \textit{LICENSED\_OLD\_KEY} both were handled as valid, since \textit{LICENSED} jumps into the next case.
After the patch, \textit{NOT\_LICENSED} starts where \textit{LICENSED\_OLD\_KEY} started before.
Now, \textit{LICENSED} and \textit{NOT\_LICENSED} have the same behavior which means even though the response code is \textit{NOT\_LICENSED}, it is treated as valid.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={11-16},
 caption={Diff on Java level for \textit{Patch Pattern N1}},
 label={codeSnippet:n1DiffJava}
]{data/n1.diff}
The result is the voiding of the \textit{verify()} switch case.
It handles the user as verified even though the response code is \textit{NOT\_LICENSED} at the cost of the response code \textit{LICENSED\_OLD\_KEY}.
This response code is send when the developer changes the signature of the license verification process and updates the application.
This happens rarely but when it does, a newer version of the application has to be cracked.

\subsubsection{Patch Pattern N2}
Like \textit{Patch Pattern N1}, \textit{Patch Pattern N2} is applied in all patching modes, except the solo extreme mode.
It is more aggressive, since it does not only attack the \gls{lvl} library, but extends it attacks to other Google Mobile Service (\textit{gms}) libraries, i.a. \textit{com/google/android/gms/ads/}.
The analysis of different applications shows custom libraries are attacked as well.
An example is AnjLab's inapp billing library \cite{inappBilling} of FKUpdater, located at \textit{com/anjlab/android/iab/v3/Security}.
The library contains code for the Google in app billing.
Other locations are targeted in order to find a moved \gls{lvl}.
Similar to \textit{Patch Pattern N1}, \textit{Patch Pattern N2} targets the \textit{LicenseValidator} class's \textit{verify()} method.
\newline
The changes in the \gls{dex} file can be seen in code snippet~\ref{codeSnippet:n2DiffDex}.
First, the mask of the search pattern has to match with the fixpoints on the dex bytecode.
When a matching is successful, the replace pattern is applied.
The result of \textit{Patching Pattern N2} is the replacing of the instruction \textit{0a 05} with the instruction \textit{12 15}.
\gls{luckypatcherg} uses the placeholder \textit{S1} for the second bytecode.
The target of the opcode altered remains the same while the source is modified while the source of the opcode is modified.
The placeholder indicates the source is set to \textit{1}.
\textit{Patch Pattern N2} has one pair of search and replace pattern in the code of \gls{luckypatcherg}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-7},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N2}},
 label={codeSnippet:n2DiffDex}
]{data/n2.diff}
The smali in code snippet~\ref{codeSnippet:n2DiffSmali} shows the altered instruction.
Instead of moving the result of the preceding function to variable \textit{v5}, it is always set to \textit{true}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={9-11},
 caption={Diff on Smali level for \textit{Patch Pattern N2}},
 label={codeSnippet:n2DiffSmali}
]{data/n2.diff}
The result in the Java code (see code snippet~\ref{codeSnippet:n2DiffJava}) shows more than just the setting of a variable to \textit{true}.
Instead of proceeding according to the result of the verification of the signature, the result is ignored and the execution is continued inside the condition.
The Java code looks different since the decompiler collapses the \textit{if(true)} statement.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={13-15},
 caption={Diff on Java level for \textit{Patch Pattern N2}},
 label={codeSnippet:n2DiffJava}
]{data/n2.diff}
The consequence is that \textit{verify()} of the signature still executed but the result is ignored.
The program flow continues after  \textit{verify()} as if the signature was valid.

\subsubsection{Patch Pattern N3}
\textit{Patch Pattern N3} is applied differently in the auto, \textit{N3}, and the auto inversed auto mode, \textit{N3i}.
It targets the \textit{allowAccess()} method inside the \textit{APKExpansionPolicy} and \textit{ServerManagedPolicy}.
These two classes are the policies examples provided by Google and located \textit{com/google/android/vending/licensing/} folder \cite{developersLicensingReference}.
\newline
The \textit{Patch Patterns} have an opposing result.
While \textit{Patch Pattern N3}is replacing the \textit{01} with \textit{11}, \textit{Patch Pattern N3i} does the opposite by replacing \textit{11} with \textit{01} (see code snippet~\ref{codeSnippet:n3DiffDex}).
\newline
The source code of \gls{luckypatcherg} contains three categories of patterns.
The first category are the four bytecode patterns for \textit{Patch Pattern N3}.
It replaces the target instructions arguments with the the placeholder \textit{S1}, i.e. the sources of the target instructions are set to \textit{1}.
\newline
The second category are the four bytecode patterns for \textit{Patch Pattern N3i}.
Instead of setting the sources to \textit{1}, the bytecode patterns replace the two target instructions’ sources with \textit{0}, as the placeholder \textit{S0} indicates.
\newline
While the four patterns of \textit{N3} and \textit{N3i} have the same context but different variables, the two patterns of \textit{N3x} are different in their structure but enforce the same logic as the other patterns.
The first bytecode pattern of \textit{N3x} targets implementations using \textit{13}, a move for a wide constant.
In this case the variable \textit{W0} is set depending on \textit{R0}.
The second bytecode pattern of \textit{N3x} is applied when the integer value is retrieved from an array (\textit{44}).
The instruction is replaced by \textit{12 10} and a \textit{00 00}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-8},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N3}},
 label={codeSnippet:n3DiffDex}
]{data/n3.diff}
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={10-17},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N3i}},
 label={codeSnippet:n3DiffDex}
]{data/n3.diff}
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={19-24},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N3x}},
 label={codeSnippet:n3DiffDex}
]{data/n3.diff}
When looking at the smali diff in code snippet~\ref{codeSnippet:n3DiffDex}, the dex code is translated to the initialization of \textit{v1}.
While N3 sets \textit{v1} to \text{1}, N3i sets \textit{v1} to \textit{0}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={26-32},
 caption={Diff on Smali level for \textit{Patch Pattern N3} and \textit{N3i}},
 label={codeSnippet:n3DiffSmali}
]{data/n3.diff}
The resulting Java code is shown in code snippet~\ref{codeSnippet:n3DiffJava}.
The \textit{Patch Pattern} enforces the result of the \textit{allowAccess()} method by already initializing the result value with the desired outcome.
While N3 is targeted towards code where the default return value is \textit{false}, \textit{Patch Pattern N3i} is used when the default value is \textit{true}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 float=h,
 frame=single,
 linerange={34-44},
 caption={Diff on Java level for \textit{Patch Pattern N3} and \textit{N3i}},
 label={codeSnippet:n3DiffJava}
]{data/n3.diff}
Both \textit{Patch Patterns} attack the class's \textit{allowAccess()} method which evaluates whether the verification result is according to the policy or not.
Both variables, which can be returned as result, are initialized with the same value.
This makes the result independent of the outcome of the verification.
As LP cannot predict if the answer \textit{true} or \textit{false} allows continuation of the license verification process, it offers both versions and the user has to try which is the right one.
This is the reason for the inverse auto mode since it is the only difference between that mode and the auto mode.

\subsubsection{Patch Pattern N4}
 \textit{Patch Pattern N4} is part of the auto and auto inverse patching modes.
The target of the \textit{Patch Pattern} is the \textit{LicenseChecker} class of the \gls{lvl}, which is responsible for initializing the license check in its \textit{checkAccess()} method \cite{developersLicensingReference}.
\newline
As seen in code snippet~\ref{codeSnippet:n4DiffDex}, it replaces \textit{38} with \textit{33}.
The one bytecode pattern found in \gls{luckypatcherg}’s source code shows that the arguments of \textit{33} are set to \textit{00} instead of the original bytecode tupel.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-8},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N4}},
 label={codeSnippet:n4DiffDex}
]{data/n4.diff}
In the smali code snippet~\ref{codeSnippet:n4DiffSmali} this change can be identified as replacing \textit{if-eqz} with \textit{if-ne}.
The opcode \textit{if-eqz} takes one argument \textit{v0} and implicitly fills the remainder of the tuple with \textit{0}, while \textit{if-ne} takes two arguments and interprets the implicit \textit{0} as \textit{v0}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={10-12},
 caption={Diff on Smali level for \textit{Patch Pattern N4}},
 label={codeSnippet:n4DiffSmali}
]{data/n4.diff}
The Java code in code snippet~\ref{codeSnippet:n4DiffSmali} shows the result of the change.
In the original code, the result of \textit{mPolicy.allow()} was checked.
In case the policy did not allow to continue, i.e. the result was \textit{false}, the condition block was executed.
The change results in the check for inequality of the result of \textit{mPolicy.allow()}.
Since the result of the method is identical, if called twice, and thus the condition is never fulfilled and the condition block is never called.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={14-16},
 caption={Diff on Java level for \textit{Patch Pattern N4}},
 label={codeSnippet:n4DiffJava}
]{data/n4.diff}
\textit{Patch Pattern N4} ensures that the result of textit{checkAccess()} is never considered.

\subsubsection{Patch Pattern N5}
As part of the extreme mode, \textit{Patch Pattern N5} targets the \textit{LicenseValidator}'s \textit{verify()} method.
It targets implementations with other context than the basic implementation of the \gls{lvl}.
\newline
The diff of the dex code in code snippet~\ref{codeSnippet:n5DiffDex} shows the replacing of \textit{0a} with \text{12}.
\textit{Patch Pattern N5} makes use of three bytecode patterns with different context, found in the source code of \gls{luckypatcherg}.
The location of the change is dependent the eight fixpoints of each search pattern mask.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-9},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N5}},
 label={codeSnippet:n5DiffDex}
]{data/n5.diff}
The modification done by \textit{Patching Pattern N5} is moving to a variable a constant (\textit{const/4}) instead of a result (\textit{move-result}).
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={11-13},
 caption={Diff on Smali level for \textit{Patch Pattern N5}},
 label={codeSnippet:n5DiffSmali}
]{data/n5.diff}
The result of patching can be seen in the Java diff in code snippet~{codeSnippet:n5DiffJava} .
The original code parses the response code from the data record of the server.
After applying the patch, the response data is still parsed but the result is ignored and the response code is set to \textit{0}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={15-18},
 caption={Diff on Java level for \textit{Patch Pattern N5}},
 label={codeSnippet:n5DiffJava}
]{data/n5.diff}
The \textit{Patch Pattern} sets the response code of the object to \textit{LICENSED}.
The real response code is ignored and the code continues even though the server did not positively verify the license.

\subsubsection{Patch Pattern N6}
 \textit{Patch Pattern N6} is part of the extreme mode and, similar to the \textit{Patch Pattern N1}, \textit{N2} and \textit{N5}, it attacks the \textit{verify()} method in the \gls{lvl}'s \textit{LicenseValidator} class.
\newline
This \textit{Patch Pattern} has only one bytecode pattern pair, which targets three bytecode tuples of the \gls{dex} file which can be seen in code snippet~\ref{codeSnippet:n6DiffDex}.
The first changes value is \textit{38} to \textit{12}.
The second value is \textit{06} which is replaced by \textit{00}.
The third change is the replacing of \textit{4a} by \textit{00}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-8},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for \textit{Patch Pattern N6}},
 label={codeSnippet:n6DiffDex}
]{data/n6.diff}
The change of the code structure is more visible in the code snippet~\ref{codeSnippet:n6DiffSmali}.
The first results in the initialization of \textit{p2} with \textit{0}.
The second change is required to maintain the length of the sequence.
The opcode \textit{const/4} has two bytecode tuples as argument, while the original \textit{if-eqz} has four - the opcode tuple, the argument tuple and a target consisting of two tuples.
The difference is fixed by changing the third and fourth bytecode tuple to a \textit{nop} operation (\textit{00 00}).
It is presented as \textit{nop} and an empty line.
The third change is the replacing arguments \textit{p2} and \textit{v4} of the \textit{if-eq} evaluation with \textit{v0} for each.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={10-17},
 caption={Diff on Smali level for \textit{Patch Pattern N6}},
 label={codeSnippet:n6DiffSmali}
]{data/n6.diff}
The changes on Java level of the \textit{Patch Pattern} are presented in code snippet~\ref{codeSnippet:n6DiffJava}.
In the original code the if statement tests whether the response code is not one of the desired values.
After patching, the evaluation is always false and the code block inside is never used.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={19-24},
 caption={Diff on Java level for \textit{Patch Pattern N6}},
 label={codeSnippet:n6DiffJava}
]{data/n6.diff}
This \textit{Patch Pattern} prevents the execution for cases where the \textit{verify()} has to handle response codes that are neither \textit{LICENSED}, \textit{NOT\_LICENSED} or \textit{LICENSED\_OLD\_KEY}.
Instead the method proceeds as if the response code is valid.

\subsubsection{Patch Pattern N7}
The final \textit{Patch Pattern} for the \gls{lvl} is \textit{Patch Pattern N7}.
Inside the lvl, it patches the \textit{ILicenseResultListener} class's \textit{onTransact()} method, which receives the asynchronous response from the license server \cite{developersLicensingReference}.
In addition to the lvl classes, the \textit{Patch Pattern} is applied to all classes residing in the \url{com/android/} package.
\newline
\textit{Patch Pattern N7} has seven bytecode pattern pairs, which all replace \textit{0a} with \textit{12}, but in different contexts.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-11},
 caption={Diff on dex level for N7 patch},
 label={codeSnippet:n7DiffDex}
]{data/n7.diff}
In smali, this shows to be the replacement of moving a result into \textit{v1} by initializing \textit{v1}  to \textit{0}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={13-15},
 caption={Diff on Smali level for N7 patch},
 label={codeSnippet:n7DiffSmali}
]{data/n7.diff}
Similar to \textit{Patch Pattern N2}, \textit{Patch Pattern N7} attacks by initializing a variable with \textit{false} instead of moving a result of a method into it.
\newline
\gls{luckypatcherg} uses the search pattern for this \textit{Patch Pattern} on a broader scope and it is applied when the context matches.
This can result in changes in unknown classes and thus lead to instability.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={17-20},
 caption={Diff on Java level for N7 patch},
 label={codeSnippet:n7DiffJava}
]{data/n7.diff}
This \textit{Patch Pattern} ensures the \textit{verifyLicense()} method is always executed with the constant \textit{LICENSED} instead of the result of the licensing check.

\subsubsection{Amazon Market Patch}
\textit{Kiwi} library is injected by Amazon and cannot be customized by the developer.
This means only one \textit{Patch} is necessary.
The \textit{Amazon Market Patch} has two bytecode patterns, each is applied once when patching.
The first class targeted is \textit{com/amazon/android/licensing/b.java} while the second class is \textit{com/amazon/android/o/d.java}.
While \textit{b.java} is responsible for the verification of the license, \textit{d.java} is reponsible for handling the expiration of the license.
\newline
The \textit{Amazon Market Patch} has two bytecode pattern to replaces (\textit{38}) with (\textit{33}).
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-8},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for the \textit{Amazon Market Patch}},
 label={codeSnippet:amazonDiffDex}
]{data/amazon.diff}
The patch replaces \textit{if-eqz} with \textit{if-ne} as seen in code snippet~\ref{codeSnippet:n4DiffSmali}.
The opcode \textit{if-eqz} evaluates only the one argument, comparing it to zero.
\textit{if-ne} takes two arguments, comparing them for non-equality.
Having both arguments the same always yields false and the condition code block is never executed.
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={10-12},
 caption={Diff on Smali level for the \textit{Amazon Market Patch}},
 label={codeSnippet:amazonDiffSmali}
]{data/amazon.diff}
The Java code presentation helps to interpret the changes of the attack.
Since the if statement is now always wrong the code block for response codes not \textit{APPLICATION\_LICENSE} is never called.
The same changes are applied to the \text{d.java} class.
Analysis of the dependencies shows the function checks whether the given string is not null and then returns \textit{true}.
After patching, the result of \textit{v0.equals(...)} always \textit{true} and the entire if condition is always \textit{false}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={14-16},
 caption={Diff on Java level for the \textit{Amazon Market Patch}},
 label={codeSnippet:amazonDiffJava}
]{data/amazon.diff}
The changes void the if statement for checking whether the response code is \textit{APPLICATION\_LICENSE}.
The result is forced to be always \textit{true} and thus the license verification always passes.

\subsubsection{SamsungApps Patch}
Similar to the Amazon \textit{Kiwi} library, Samsung's \textit{Zirconia} library cannot be modified by the developer.
For this reason cracking the library requires only one \textit{Patch}, consisting of two \textit{Patch Pattern}, \textit{S1} and \textit{S2}.
The \textit{SamsungApps Patch} is applied on the \textit{LicenseRetriever} and \textit{Zirconia} class in the \textit{com/samsung/zirconia} package.
\textit{S1} is applied on both classes once and \textit{Patch Pattern S2} is applied twice but only on the \textit{Zirconia} class.
\newline
\textit{S1} uses six bytecode pattern pairs while \textit{S2} has two bytecode pattern pairs.
While the bytecode patterns \textit{S1} replace \textit{d6} with \textit{00}, the ones for \textit{S2} use \textit{12} instead of \textit{0a}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={1-9},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for the \textit{Patch Pattern S1}},
 label={codeSnippet:samsungDiffDex1}
]{data/samsung.diff}
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={11-20},
 caption={ Diff on dex level and search and replace bytecode pattern to apply for the \textit{Patch Pattern S2}},
 label={codeSnippet:samsungDiffDex2}
]{data/samsung.diff}
The result of \textit{Patching Pattern S1} is that the \textit{if-eq} statement instead of comparing two variables only compares \texit{v0} to itself.
The result of this comparison is always \textit{true}.
\newline
\textit{Patching Pattern S2} has the effect that \textit{v0} does not return the result of the preceding method but always \textit{true}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={22-28},
 caption={Diff on Smali level for the \textit{SamsungApps Patch}},
 label={codeSnippet:samsungDiffSmali}
]{data/samsung.diff}
The presentation in code snippet~\ref{codeSnippet:samsungDiffJava} contains the changes in Java code.
Instead of continuing execution based on the result of \textit{foo()} (\textit{LicenseRetriever}'s \textit{receiveResponse()}), it executes \textit{foo()}, but ignores the result and proceeds as if it was true.
Instead of checking the response code for validity, \textit{LicenseRetriever}'s \textit{receiveResponse()} method always skips the check, when \textit{Patching Pattern S1} is applied, and executes as if it was valid.
In the method \textit{checkerThreadWorker()} of the \textit{Zirconia} class, \textit{Patching Pattern S1} voids the check of the response code and always continues as if the response code was valid.
\newline
\textit{Patching Pattern S2} works on the methods \textit{checkLicenseFile()} and \textit{checkLicenseFilePhase2()} of the \textit{Zirconia} class.
Instead of returning the result of the license check, the methods return always \textit{true}.
\newline
\lstinputlisting[
 style=diff,
 breakatwhitespace=false,
 breaklines=true,
 captionpos=b,
 frame=single,
 linerange={30-37},
 caption={Diff on Java level for the \textit{SamsungApps Patch}},
 label={codeSnippet:samsungDiffJava}
]{data/samsung.diff}
The result of applying the patch is that not only the license file checks are voided and return the verification as \textit{true}.
In addition, response codes other than \textit{LICENSED} are accepted since they are neither checked for validity nor to the stored one, which should be valid since it was stored.
