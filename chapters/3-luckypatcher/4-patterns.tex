\section{Patching Patterns} \label{section:luckypatcher-patterns}
In order to identify the structure of the single patterns, the code of the original code was compared to the cracked output.
The changes in the code were inspected on dex, smali and Java level with the tools explained in Section~\ref{section:reengineering}.
After analysing same patterns in the different modes it was identified that these patterns can be summed up as one.
\newline
The names of the patterns are taken from the patching result output in figure~\ref{fig:luckyScreen} on the right.
The number next to the pattern indicates how often it was applied to the application.
The patterns N\textit{x} aim to circumvent the \gls{lvl} while the Amazon and Samsung patterns are tailored to the respective store.
This insight was gained in the analysis.
In the context of the \gls{dex}, hexadecimal values like \textit{0x0a} are simplified as \textit{0a} for smoother reading.


\subsubsection{Patch Pattern N1}
Pattern N1 is present in all patching modes except the solo extreme mode.
It tagets the \textit{verify()} function of \textit{LicenseValidator} class in the \textit{com/google/android/vending/licensing/} folder which is responsible for dectypting and verifying the response from the license server \cite{developersLicensingReference}.
\newline
When analysing the dex code, it is identified that the changes happen in the switch statement.
The code block starts \textit{00 02}, which stands for a sparse-switch, followed by \textit{09 00}, which gives the number of elements \cite{opcodes}.
According to diff of the \gls{dex} file extracted, which can be seen in code snippet~\ref{codeSnippet:n1DiffDex}, element 1a and 0f are switched in their order, meaing 0f is now before 1a in the sequence of the switch.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N1 pattern},
  label={codeSnippet:n1DiffDex}
]{data/n1.diff}

Smali, which converts the \gls{dex} file to a human readable output, a code representation where result of opcode changes are easier assigned to functions.
When converting the byte code to smali, a sparse switch struct with nine elements is created.
Due to the internal mapping by the language, variables have different names.
The swap of switch cases \textit{0x1} und \textit{0x2} can be seen in the diff of code snippet~\ref{codeSnippet:n1DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-9},
  caption={Diff on Smali level for N1 pattern},
  label={codeSnippet:n1DiffSmali}
]{data/n1.diff}

The diff of Java, seen in code snippet~\ref{codeSnippet:n1DiffJava}, gives the best overview on the changed behavior of the application, since it does not contain jumps to abstract function names but includes the code as the developer intended it.
Since the cracking pattern was also applied to the LicenseTest application, it is possible to compare the decompiled code to the original source code and it's original structure.
The original library handles the \textit{LICENSED} reponse the same way as \textit{LICENSED\_OLD\_KEY}, since not having a breakpoint in the \textit{LICENSED} switch case, the code subsequently continues in the \textit{LICENSED\_OLD\_KEY} switch case and leaving it afterwards.
The is only the reason if license keys are stored and allowed for verification, e.g. one time verification for future offline support.
The entry point for a \textit{NOT\_LICENSED} response is follows after these two cases and is completed by a break to exit the switch case.
When the pattern N1 is applied, the switch case statements of \textit{LICENSED\_OLD\_KEY} and \textit{NOT\_LICENSED} are swapped, but not the code inside the block.
This means that instead of \textit{NOT\_LICENSED} disallow the licensing process, it makes use of the \textit{NOT\_LICENSED} condition and allows access.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={11-15},
  caption={Diff on Java level for N1 pattern (abstracted)},
  label={codeSnippet:n1DiffJava}
]{data/n1.diff}

As a results, pattern N1 voids the usecase of the switch in the function \textit{verify()} since it always handles \textit{NOT\_LICENSED} response codes the same way as \textit{LICENSED}.


\subsubsection{Patch Pattern N2}
As well as pattern N1, N2 is applied in all patching modes, except the solo extreme mode.
It is more aggressive since it does not only attack the \gls{lvl} library, but extends it attacks to other Google Mobile Service libraries, located at \textit{com/google/android/gms/ads/}.
The extended analysis of different applications showed the altering of custom libraries, which include code for Google inapp billing, like AnjLab's inapp billing library \cite{inappBilling}, located at \textit{com/anjlab/android/iab/v3/Security}, in the FKUpdater, are modified as well.
This is collateral damage when applying the pattern to classes outside of the \gls{lvl} libary caused by the possibility of moving the classes of the library to different packages.
As long as the \gls{lvl} package is untouched, pattern N2, similar to pattern N1, attacks the \textit{LicenseValidator} class's \textit{verify()} function.
\newline
The changes in the \gls{dex} file in code snippet~\ref{codeSnippet:n2DiffDex} effect a simpler construct than pattern N1 does.
Instead of of using the opcode \textit{0a} for moving the result the result of the corresponding function to the variable 5 (source-destination order of \textit{05}), it simply moves (opcode \textit{12}) the value 1, which stands for true, to the variable 5 (\textit{15}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N2 pattern},
  label={codeSnippet:n2DiffDex}
]{data/n2.diff}

Smali displays this in a more convenient manner as seen in code snippet~\ref{codeSnippet:n2DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for n2 pattern},
  label={codeSnippet:n2DiffSmali}
]{data/n2.diff}

The impact on the Java code (see code snippet~\ref{codeSnippet:n2DiffJava}) is more complex.
Now, instead of calling additional code in case the signature is verified, the additional code is always called.
The reason for this structural change in code is the fact that in dex the if statement is split.
In a first step, the signature is verified , while in the second step the result is moved to a variable and this variable is evaluated in the third step.
Since the first step is not modified, it is still interpreted as a function by the decompiler.
For the second and third step it is different.
The reason is the decompiler since the variable is set with the constant value true and checked afterwards in an if evaluation.
In order to simplify and remove superfluous code, the if statement is collapsed and the body is moved to outer scope.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N2 pattern (abstracted)},
  label={codeSnippet:n2DiffJava}
]{data/n2.diff}

The conclusion is that after applying this pattern the result of the verification of the signature is no longer included in the logic of \textit{verify()}.

\subsubsection{Patch Pattern N3}
This pattern is different than the other patterns since there are two versions of it.
Pattern N3 is present when using auto mode while pattern N3i is used in the inversed auto mode.
The name N3i is chosen since it is used in the inversed auto mode.
LuckyPatcher does not make a difference between them.
They are combined under the same number since both attack the same logic inside the classes which define the policies.
In case of LicenseTest application with the basic implementation of the \gls{lvl}, these classes are the \textit{APKExpansionPolicy} and \textit{ServerManagedPolicy} in the  \textit{com/google/android/vending/licensing/} folder.
Those two classes are examples of policies offered by Google \cite{developersLicensingReference} in which the \textit{allowAccess()} is altered.
\newline
The goal of the two patterns is the opposite of each other.
Both edit the value which is moved (opcode \textit{12}) into variable 1, but while N3 is moving true (opcode \textit{11}), N3i is moving false (opcode \textit{02}) (see code snippet~\ref{codeSnippet:n3DiffDex}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for N3 pattern},
  label={codeSnippet:n3DiffDex}
]{data/n3.diff}
As usual, the smali diff in code snippet~\ref{codeSnippet:n3DiffDex} delivers a better presentation of the two patterns.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for N3 pattern},
  label={codeSnippet:n3DiffSmali}
]{data/n3.diff}
The Java code in code snippet~\ref{codeSnippet:n3DiffJava} is more complex again since the structure if the code in the \gls{dex} files is different than the one in Java.
This is due to the fact that while in Java the \textit{return} followed by a value is possible, in \gls{dex} files this statement is split in two parts.
First, an internal variable is initiated with a standard value corresponding to the type of the return and in a second step the value is returned.
The patterns modify the value initialization which results in the change of the return statement in the Java code.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  float=h,
  frame=single,
  linerange={17-23},
  caption={Diff on Java level for N3 pattern (abstracted)},
  label={codeSnippet:n3DiffJava}
]{data/n3.diff}
Both patterns attack the class's \textit{allowAccess()} functions which evaluates whether the verification result is according to the policy or not.
Since this method is a place to change the logic in order to fool a cracking tool by changing the desired outcome from true to false, Lucky Patcher offers a way to deal with this implementation.
This is the reason why the mode is called inverse auto mode since it fixes the return value to the opposite of the auto mode.


\subsubsection{Patch Pattern N4}
Pattern N4 was only applied once in the test sample and is part of the auto and auto inverse patching modes.
The target of the pattern is the \textit{LicenseChecker} class of the \gls{lvl} which is responsible for instantiating the license check in it's \textit{checkAccess()} function \cite{developersLicensingReference}.
\newline
When the pattern is applied, it replaces the function's equal zero check (\textit{38}) with a check for not equal (\textit{33}) as it can be seen in code snippet~\ref{codeSnippet:n4DiffDex} and code snippet~\ref{codeSnippet:n4DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N4 patch},
  label={codeSnippet:n4DiffDex}
]{data/n4.diff}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for N4 patch},
  label={codeSnippet:n4DiffSmali}
]{data/n4.diff}
in the original code variable v0 is compared for not equality with zero
after it is patched it is always compared with itself which returns always true and the condition is always called

Since the code's syntax is changed when compiled from Java to dex, the decompiled code has a different sequence.
In the source code of the \gls{lvl}, the \textit{checkAccess()} first checks whether the policy allows acces.
When decompiled, it is checked for not equality first and the source code's equality block is moved to the else condition.
This results in the initial equals zero condition and latter not equal test.
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N4 patch (abstracted)},
  label={codeSnippet:n4DiffJava}
]{data/n4.diff}


The result is that even though policy does not allow the access, this patterns modifies the \textit{checkAccess()} function to act as it would have been allowed anyway.


\subsubsection{Patch Pattern N5}
As part of the extreme mode, pattern N5 works on the \gls{dex} file similar to pattern N2 on the \textit{LicenseValidator}'s \textit{verify()} method. It does not affect the standard implementation of the \gls{lvl}.
\newline
As described before, the dex code is has a more complex decompiled Java code than the source code, especially in this case since instead of calling attributes of an object directly it stores them into variables before.
In this decompiled code, the parsing of the result code is spoofed and not the value of the response data is stored but the response code is set to 0.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-4},
  caption={Diff on Java level for N5 patch (abstracted)},
  label={codeSnippet:n4DiffJava}
]{data/n5.diff}

If this pattern would be applied alone, it would be able to circumvent the response code checks, but it is effective when combined with pattern N6.


\subsubsection{Patch Pattern N6}
classes it attacks %GENAUER ERKLÄREN WAS SIE MACHEN, FUNKTION DIE ANGEGRIFFEN WIRD NENNEN UND ERKLÄREN%
\url{com/google/android/vending/licensing/LicenseValidator.java}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N6 patch},
  label={codeSnippet:n6DiffDex}
]{data/n6.diff}

if-eqz is replaced by move constant, variables for if-eq are changed

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-12},
  caption={Diff on Smali level for N6 patch},
  label={codeSnippet:n6DiffSmali}
]{data/n6.diff}

instead of testing for zero and then calling a condition, the to test variable is changed and the condition removed
the second equal check is done by comparing a variable with itself thus always true and the conidition is called

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={14-17},
  caption={Diff on Java level for N6 patch (abstracted)},
  label={codeSnippet:n6DiffJava}
]{data/n6.diff}

instead checking two variables for a case, the condition is just always called
\subsubsection{Patch Pattern N7}
classes it attacks %GENAUER ERKLÄREN WAS SIE MACHEN, FUNKTION DIE ANGEGRIFFEN WIRD NENNEN UND ERKLÄREN%
\url{com/google/android/vending/licensing/ILicenseResultListener.java}
ILicenseResultListener, IPC callback implementation, receives async response from server\cite{developersLicensingReference}
einfach auf alles was in \url{com/android/} ist, some kind of bruteforce

similar to N2, but Java result is more generic

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={13-15},
  caption={Diff on Java level for N7 patch (abstracted)},
  label={codeSnippet:n7DiffJava}
]{data/n2.diff}

instead of initializing variable with result from function, it is always initialized with false / 0
\subsubsection{Amazon Market Patch}
also applies pattern N2

classes it attacks %GENAUER ERKLÄREN WAS SIE MACHEN, FUNKTION DIE ANGEGRIFFEN WIRD NENNEN UND ERKLÄREN%, inside kiwi logic
\url{com/amazon/android/licensing/b.java}
\url{com/amazon/android/o/d.java}

see, obfuscated

similar like pattern N4

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for Amazon patch},
  label={codeSnippet:amazonDiffDex}
]{data/amazon.diff}

if-eqz is repalces by if-ne

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for Amazon patch},
  label={codeSnippet:amazonDiffSmali}
]{data/amazon.diff}
in the original code variable v0 is compared for not equality with zero
after it is patched it is always compared with itself which returns always true and the condition is always called

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-12},
  caption={Diff on Java level for Amazon patch (abstracted)},
  label={codeSnippet:amazonDiffJava}
]{data/amazon.diff}

in the original code the result from the server is tested whether it is \textit{LICENSED}
after patching the response is always evalauted and the result is compared with itself which is always true

result
never the less what the check for \textit{LICENSED} returns, the condition for \textit{LICENSED} is always called
\subsubsection{Samsung Market Patch}
also applies pattern N2

classes it attacks %GENAUER ERKLÄREN WAS SIE MACHEN, FUNKTION DIE ANGEGRIFFEN WIRD NENNEN UND ERKLÄREN%, inside zirconia logic
\url{com/samsung/zirconia/LicenseRetriever.java}
\url{com/samsung/zirconia/Zirconia.java}

not obfuscated

two patterns, lets call it S1 and S2, S1 used on both, S2 used twice on zirconia

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for Samsung patch},
  label={codeSnippet:samsungDiffDex}
]{data/samsung.diff}

S1
input for if-eq is modified
S2
move-result is replaced by move const

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for Samsung patch},
  label={codeSnippet:samsungDiffSmali}
]{data/samsung.diff}
S1
in the original code checks whether to different variables are equal
after patching the check is done with the same variables and thus always returns true

S3
in the original code the result of a function is moved to v0 and returned
after patching true/1 is always moved to v0 and returned

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={17-23},
  caption={Diff on Java level for Samsung patch (abstracted)},
  label={codeSnippet:samsungDiffJava}
]{data/samsung.diff}

\url{com/samsung/zirconia/LicenseRetriever.java}
always starts condition, even though input is not \textit{12} as supposed to start
\url{com/samsung/zirconia/Zirconia.java}
S1
always returns true for checkLicenseFile and checkLicenseFilePhase2, does not check anything which is done normally
S2
always starts condition, even though input is not as supposed to start
\url{com/samsung/zirconia/Zirconia.java}
\begin{table}[h]
\centering
\begin{tabular}{l|cccccccc}
                           & \multicolumn{8}{c}{Patterns}           \\
\multicolumn{1}{c|}{Modus} & N1 & N2 & N3 & N3i & N4 & N5 & N6 & N7 \\ \hline
Auto                       & X  & X  & X  &     & X  &    &    &    \\
Auto (Inversed)            & X  & X  &    & X   & X  &    &    &    \\
Extreme                    &    &    &    &     &    & X  & X  & X  \\
Auto+Extreme               & X  & X  & X  &     & X  & X  & X  & X  \\
Auto (Inversed)+Extreme    & X  & X  &    & X   & X  & X  & X  & X
\end{tabular}
\caption{Overview of License Verification Library patching patterns applied by each modus}
\label{table:patterns}
\end{table}



summarizing what patterns each modus applies Table~\ref{table:patterns}


%detailierter
auto: just applies minimum patches, N1 swaps switch cases so not licensed is treated here as old license key in the LicenseValidator, N2 skips the signature verification in the LicenseValidator, N3 inverts the return boolean for the policy checks in the implemented Policy class by initializing with 0/false, and N4 skips, in the only case occured in the test set, the check whether download is allowed and allows it always
auto inverse: does the same as auto but initializes the policy check with 1/true instead of false
extreme:
auto+extreme: applies auto and extreme patches
auto inverse+extreme: applies auto and extreme patches




!!! kann man das excel sheet in die datein machen und nicht als appendix, da manche apps ihre ergebnisse nicht öffentlich sehen wollen !!!
