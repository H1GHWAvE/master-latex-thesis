\section{Patching Patterns} \label{section:luckypatcher-patterns}
In order to identify the structure of the single patterns, the code of the original code was compared to the cracked output.
The changes in the code were inspected on dex, smali and Java level with the tools explained in Section~\ref{section:reengineering}.
After analysing same patterns in the different modes it was identified that these patterns can be summed up as one.
\newline
The names of the patterns are taken from the patching result output in figure~\ref{fig:luckyScreen} on the right.
The number next to the pattern indicates how often it was applied to the application.
This number is not always correct.
The patterns N\textit{x} are used to circumvent the \gls{lvl} while the Amazon and Samsung patterns are tailored to do the same with the library of the respective store.
Additional knowledge on the patterns was was gained in the analysis.
\newline
Before explaining the patterns in detail, some information has to be provided.
When analyzing \gls{dex} files, instead of using hexadecimal values like \textit{0x0a}, a simplified presentation as \textit{0a} for improved overview in the diff files is chosen.
The opcodes used by the \gls{dvm} are taken from on of the documentations \cite{opcodes}.
When converting \gls{dex} files to smali files, the arguments of the opcodes are transfered to variables, e.g. \textit{x} in dex code is v\textit{x} in smali.
\newline
Since changing the dex code of an application results in a new checksum, the code has to be resigned as well.
This changes can be seen in the diff of the dex files.
They are not explicit mentioned in the analysis since it is no direct change of the attack.

\subsubsection{Patch Pattern N1}
Pattern N1 is present in all patching modes except the solo extreme mode.
It tagets the \textit{verify()} method of \textit{LicenseValidator} class in the \textit{com/google/android/vending/licensing/} folder.
This method is responsible for dectypting and verifying the response from the license server \cite{developersLicensingReference}.
\newline
In can be seen in the dex code in code snippet~\ref{codeSnippet:n1DiffDex} that the the blocks \textit{1a} and \textit{0f} are swapped in their order.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N1 pattern},
  label={codeSnippet:n1DiffDex}
]{data/n1.diff}
When looking at the smali code, the two blocks can be identified as cases of a switch statement.
Due to the internal mapping by the language, variables have different names.
The swap of switch cases \textit{0x1} und \textit{0x2} can be seen in the diff of code snippet~\ref{codeSnippet:n1DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-9},
  caption={Diff on Smali level for N1 pattern},
  label={codeSnippet:n1DiffSmali}
]{data/n1.diff}
In the Java code snippet~\ref{codeSnippet:n1DiffJava}, not only the syntactic but also semantic changes can be seen.
Before the patch, \textit{LICENSED} and \textit{LICENSED\_OLD\_KEY} both were handled as valid since \textit{LICENSED} jumps into the next case.
After the patch, \textit{NOT\_LICENSED} starts where \textit{LICENSED\_OLD\_KEY} started before.
Now, \textit{LICENSED} and \textit{NOT\_LICENSED} have the same behavior which means even though the response code is \textit{NOT\_LICENSED} it is valid.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={11-16},
  caption={Diff on Java level for N1 pattern (abstracted)},
  label={codeSnippet:n1DiffJava}
]{data/n1.diff}
The result is the voiding of the \textit{verify()} switch case since despite the input it always handles it as if the user is verified.

\subsubsection{Patch Pattern N2}
As well as pattern N1, N2 is applied in all patching modes, except the solo extreme mode.
It is more aggressive since it does not only attack the \gls{lvl} library, but extends it attacks to other Google Mobile Service (gms) libraries, e.g.  \textit{com/google/android/gms/ads/}, as well.
The extended analysis of different applications shows the altering of custom libraries as well.
An example is AnjLab's inapp billing library \cite{inappBilling} in the FKUpdater, located at \textit{com/anjlab/android/iab/v3/Security}, which includes code for the Google inapp billing.
This happens since the pattern is applied to other locations as well to counter a moved \gls{lvl}.
Similar to pattern N1, pattern N2 attacks the \textit{LicenseValidator} class's \textit{verify()} method.
\newline

The changes in the \gls{dex} file can be seen in code snippet~\ref{codeSnippet:n2DiffDex}.
The sequence \textit{0a 05} is replaced by \textit{12 15}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N2 pattern},
  label={codeSnippet:n2DiffDex}
]{data/n2.diff}
Smali displays this in a more convenient manner as seen in code snippet~\ref{codeSnippet:n2DiffSmali}.
Instead of moving the result of the proceeding function to \textit{v5} it is always set to \textit{true}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for n2 pattern},
  label={codeSnippet:n2DiffSmali}
]{data/n2.diff}

The impact on the Java code (see code snippet~\ref{codeSnippet:n2DiffJava}) is more complex than just setting a variable to true.
Instead of proceeding only if the signature is verified, the result is ignored and the following code is always executed.
The Java code looks different since the decompiler collapses the \textit{if(true)} statement.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N2 pattern (abstracted)},
  label={codeSnippet:n2DiffJava}
]{data/n2.diff}

The result is that the despite a possibly invalid signature the code of \textit{verify()} is executed anyways.

\subsubsection{Patch Pattern N3}
Pattern N3 is different than the other patterns since there are two versions of it.
The first version, N3, is used in auto mode while pattern N3i is used in the inversed auto mode.
The name N3i is chosen since it is used in the inversed mode.
LuckyPatcher does not make a difference between them in the result ouput.
They are combined under the same number since both attack the same logic inside the classes defining the policies.
In case of the basic implementation of the \gls{lvl}, these classes are the \textit{APKExpansionPolicy} and \textit{ServerManagedPolicy} in the  \textit{com/google/android/vending/licensing/} folder.
Those two classes are examples of policies offered by Google \cite{developersLicensingReference}.
Pattern N3 attacks their \textit{allowAccess} method.
\newline
In case of pattern N3, \textit{01} is replaced with \textit{11}, while in case of N3i \textit{11} is replaced by \textit{01} (see code snippet~\ref{codeSnippet:n3DiffDex}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for N3 pattern},
  label={codeSnippet:n3DiffDex}
]{data/n3.diff}
When looking at the smali diff in code snippet~\ref{codeSnippet:n3DiffDex}, the dex code is translated to the initialization of \textit{v1}.
While N3 sets \textit{v1} to \text{1}, N3i sets \textit{v1} to \textit{0}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for N3 pattern},
  label={codeSnippet:n3DiffSmali}
]{data/n3.diff}
The resulting code is shown in code snippet~\ref{codeSnippet:n3DiffJava}.
The pattern attacks the result of the function.
While N3 is used to attack code where the default return value is \textit{false}, pattern N3i is used when the default value is \textit{true}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  float=h,
  frame=single,
  linerange={17-25},
  caption={Diff on Java level for N3 pattern (abstracted)},
  label={codeSnippet:n3DiffJava}
]{data/n3.diff}
Both patterns attack the class's \textit{allowAccess()} method which evaluates whether the verification result is according to the policy or not.
The return value is only changed in case the test of the input is evaluated accordingly, if this is not the case, it is not changed.
The pattern changes the default return value and thus makes the result of the evaluation negligible since the desired result is already set.
There are two versions of the pattern to counter inversed logic which can be inplemented easily.

\subsubsection{Patch Pattern N4}
Pattern N4 was only applied once in the test sample and is part of the auto and auto inverse patching modes.
The target of the pattern is the \textit{LicenseChecker} class of the \gls{lvl} which is responsible for initializing the license check in its \textit{checkAccess()} method \cite{developersLicensingReference}.
\newline
As seen in code snippet~\ref{codeSnippet:n4DiffDex}, it replaces \textit{38} with \textit{33}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N4 patch},
  label={codeSnippet:n4DiffDex}
]{data/n4.diff}
In the smali code snippet~\ref{codeSnippet:n4DiffSmali} this change can be identified as replacing \text{if-eqz} with \text{if-ne}.
Since \text{if-eqz} evaluates only the one argument \textit{v0} and thus the second argument is \textit{0} in the \gls{dex} file, the two argument using \text{if-ne} interprets this as \textit{v0}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for N4 patch},
  label={codeSnippet:n4DiffSmali}
]{data/n4.diff}
The Java code interprets the variable \textit{v0} as boolean.
Thus instead of checking whether the result of \textit{mPolicy.allow} is \textit{false}, it compares the result for inequality with itself, which is always false.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N4 patch (abstracted)},
  label={codeSnippet:n4DiffJava}
]{data/n4.diff}


The result of patching with pattern N4 is that in the \textit{checkAccess()} method the result of whether the policy allows is never considered.


\subsubsection{Patch Pattern N5}
As part of the extreme mode, pattern N5 works on the \gls{dex} file similar to pattern N2 on the \textit{LicenseValidator}'s \textit{verify()} method. It does not affect the standard implementation of the \gls{lvl}.
\newline
As described before, the dex code is has a more complex decompiled Java code than the source code, especially in this case since instead of calling attributes of an object directly it stores them into variables before.
In this decompiled code, the parsing of the result code is spoofed and not the value of the response data is stored but the response code is set to 0.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-4},
  caption={Diff on Java level for N5 patch (abstracted)},
  label={codeSnippet:n5DiffJava}
]{data/n5.diff}

If this pattern would be applied alone, it would be able to circumvent the response code checks, but it is effective when combined with pattern N.


\subsubsection{Patch Pattern N6}
Pattern N6 is part of the extreme mode and attacks similar to the pattern N1, N2 and N5 the \textit{verify()} method in the \gls{lvl}'s '\textit{LivenseValidator} class.
\newline
The analysis of the \gls{dex} file in code snippet~\ref{codeSnippet:n6DiffDex} reveals that the attack replaces two statements.
The first modification is replacing the if equal zero (\textit{38}) with setting a constant (\textit{12}).
This results in the argument, that should have been checked for equality with zero, is now the target variable of the constant move 0 (\textit{0a}).
Since the \textit{if-eqz} opcode uses four touples, one of them is jump target which is set (\textit{06}), it has to be removed to keep the syntax of the dex code valid.
This is done by replacing the jump target with the \textit{nop} opcode (\textit{00}), which means no operation, and thus has no effect on the semantic of the code.
The second change is the modification of the follow up if statement.
Instead of checking whether the variable, which was originally checked for quality with zero, is equal (\textit{32}) to another variable (\textit{4a}), anoother variable is now compared to itself (\textit{00}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N6 patch},
  label={codeSnippet:n6DiffDex}
]{data/n6.diff}
The change of the code structure is more visible in the code snipept~\ref{codeSnippet:n6DiffSmali}.
The \textit{if-eqz} is replaced by the initialization of the p2, a nop operation and an empty line while the follow up statement has its two different arguments each exchanged with the same variable.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-12},
  caption={Diff on Smali level for N6 patch},
  label={codeSnippet:n6DiffSmali}
]{data/n6.diff}

The analysis on Java level is more complex since removing the if statement destroys the original code herarchy and makes the syntax of the class invalid.
Decompilers are built to work on correct syntax, in more complex code processes, the reverse engineered code cannot be created.
In case of the \textit{LicenseTest}, the decompiler was not successful as well, but the reversed code revealed that in the \textit{verify()} method, right after the declaration of the variables, the second if statement of the two changed ones appeared
This can be seen in the first part of the code snippet~\ref{codeSnippet:n6DiffJava}.
The rest of the method cannot be decompiled and since translating from dex or smali to Java is hard to do by a human, this change cannot be analysed any further.
This is the reason to look interpretation of code which was achieved in one of the apps, in this context it is called \textit{IntelligentGadget} because the developer denied permission to name the application.
In this application, the code was fully restored and the change was reflected in simple way.
Instead of checking the response code whether it is not null (which cannot be seen in the code but is interpreted from the source code) and equal to the given value, it is checked whether it is not zero, which is not one of the specified values of the response code.
For this reason the check for invalidity of the response code is never true and thus the termination conidition is never called.
This simple reengineered code is the result of applying pattern N5 and pattern N6 in combination.
The changes of these two patterns add up to a clean Java code as seen in the second part of the code snippet~\ref{codeSnippet:n6DiffJava}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={14-16},
  caption={Diff on Java level for N6 patch (abstracted)},
  label={codeSnippet:n6DiffJava}
]{data/n6.diff}

In general this pattern is used to void the license code checks in the \textit{verify()} method.
\subsubsection{Patch Pattern N7}
The final pattern for the \gls{lvl} is pattern N7.
It is applied in the extreme mode and as this mode indicates, it takes a harsh approach of applying itself.
In addition to patching the \gls{lvl}'s \textit{ILicenseResultListener} \textit{onTransact()} method, which is the implementation fo the callback for interprocess communication which receives the async response from the license server \cite{developersLicensingReference}, it applies it's patterns to all classes possible in the \url{com/android/}.
It can be described as the bruteforce version of pattern N2 and thus should only applied in case the other modes are not successfully.
\newline
Similar to pattern N2, pattern N7 replaces the moving of the result (\textit{0a}) of a function to the variable with initializing it with a constant (\textit{12}).
Since \textit{move-result} moves it to variable v0 (\textit{00}) the resulting initialization sets v0 to zero.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={13-15},
  caption={Diff on Java level for N7 patch (abstracted)},
  label={codeSnippet:n7DiffJava}
]{data/n2.diff}
The aim of this attack is to patch the \textit{ILicenseResultListener} at any cost so \textit{onTransact()} returns true independet of the result of \textit{verifyLicense()} which is returned in the original implementation.

\subsubsection{Overview for Patching the \gls{lvl}}
The summary of the \gls{lvl} patterns and their use in the patching modes can be seen in table~\ref{table:patterns}.
The auto mode and inversed auto mode are applying patches at the important parts of the \gls{lvl}.
They are very efficient as long as the library is not altered.
In contrast to the determined patching of the automatic modes, the extreme mode applies pattern covering a variaty of methods.
This might cause instability, as seen in pattern N6, since it alters the syntax of the dex file.
\begin{table}[h]
\centering
\begin{tabular}{l|cccccccc}
                           & \multicolumn{8}{c}{Patterns}           \\
\multicolumn{1}{c|}{Modus} & N1 & N2 & N3 & N3i & N4 & N5 & N6 & N7 \\ \hline
Auto                       & X  & X  & X  &     & X  &    &    &    \\
Auto (Inversed)            & X  & X  &    & X   & X  &    &    &    \\
Extreme                    &    &    &    &     &    & X  & X  & X  \\
Auto+Extreme               & X  & X  & X  &     & X  & X  & X  & X  \\
Auto (Inversed)+Extreme    & X  & X  &    & X   & X  & X  & X  & X
\end{tabular}
\caption{Patching patterns applied by each mode}
\label{table:patterns}
\end{table}


\subsubsection{Amazon Market Patch}
Amazon does not have different pattern but only one patch which is called pattern in this context.
Since the Kiwi library is injected by Amazon and cannot be customized by the developer as well as the structure of the library result in the fact that only on pattern is sufficient to circumvent the license verification mechanism
The patch attacks two classes, one contained \textit{com/amazon/android/licensing/b.java} and the other one contained in \textit{com/amazon/android/o/d.java}.
Since the injected library is obfuscated no meaningful names can be presented.
\newline
The Amazon pattern works similar to the \gls{lvl}'s pattern N4 and replaces the if equal zero opcode (\textit{38}) with the opcode to check for not equality (\textit{33}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for Amazon patch},
  label={codeSnippet:amazonDiffDex}
]{data/amazon.diff}
In the original code, \textit{if-eqz} just takes the second 0 of the input (\textit{00}) for the comparison thus the first argument if the input is 0.
As the result of patching, the first argument is taken as well and thus v0 is compared to v0.
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for Amazon patch},
  label={codeSnippet:amazonDiffSmali}
]{data/amazon.diff}
The Java code makes it easier to reflect of the changes byattack.
Instead of checking in the \textit{b.java} class, whether the response code is \textit{LICENSED}, this statement of the if clause is always false and thus never called.
The same canges are applied to the \text{d.java} class but since the variables are obfuscated it is hard to describe the exact behavior.
After analysing the dependencies, it can be said that the function checks whether the given string is not null and then return true.
After patching, the result is always true since the null check is always false as in \textit{b.java}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for Amazon patch (abstracted)},
  label={codeSnippet:amazonDiffJava}
]{data/amazon.diff}

The analysis of the Amazon patch indicates that there are less patterns needed since there is no altered behavior to expect.
Patches are applied to manipulate the checks in case the response code is null or different than \textit{LICENSED}.
The result is forced to be always true and thus the license verification always passes.


\subsubsection{Samsung Market Patch}
The Zirconia library of Samsung cannot be modified similar to Amazon and thus requires only one patch as well.
The patch is applied on the \textit{LicenseRetriever} and \textit{Zirconia} class in the \textit{com/samsung/zirconia} package.
Unlike Amazon's Kiwi \gls{drm}, Zirconia is not obfuscated and thus better to understand.
The Samsung patch uses two patterns, called S1 and S2 in order to distinguish between them.
While S1 is applied on both classes, S2 is applied twice but only on the \textit{Zirconia} class.
\newline
While Pattern S1 replaces the arguments of the \textit{if-eq} \textit{d6} with \textit{00} and instead of comparing two different variables, the variable is compared to itself, pattern S2 modifies the dex code to initialize a variable (\textit{12}) instead of assigning it the result of a method {\textit{0a}}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for Samsung patch},
  label={codeSnippet:samsungDiffDex}
]{data/samsung.diff}
The result of this attack for pattern S1 is that the \textit{if-eq} statement is always true while the result of methods affected by pattern S2 is always true.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for Samsung patch},
  label={codeSnippet:samsungDiffSmali}
]{data/samsung.diff}
The abstract presentation of the result in Java code in code snippet~\ref{codeSnippet:samsungDiffJava} shows the resulting behavior.
This means for \textit{LicenseRetriever}'s \textit{receiveResponse} method, that instead of checking the repsone code for validity, it is always accepted as valid.
In the method \textit{checkerThreadWorker} of the \textit{Zirconia} class, the patch voids the check of the response code with the locally stored one.
These behavior is the result of pattern S1.
Pattern S2 works on the methods \textit{checkLicenseFile} and \textit{checkLicenseFilePhase2} of the \textit{Zirconia} class.
Instead to return the result of the license check, true always is returned.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={17-24},
  caption={Diff on Java level for Samsung patch (abstracted)},
  label={codeSnippet:samsungDiffJava}
]{data/samsung.diff}
The result of applying these patches is that not only the checks of the license files are voided and return always true but also reponse codes other than \textit{LICENSED} accepted since they are neither compared to the accepted one nor to the stored one, whcih should be valid.
