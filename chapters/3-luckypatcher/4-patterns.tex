\section{Patching Patterns} \label{section:luckypatcher-patterns}
%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT

In order to identify the single patterns, the information from the output of cracking \ref{luckyInapp} right, of the apps was matched with the changes in the code. the changes in the code were inspected on dex, smali and java level with the tools explained in Section~\ref{section:reengineering}. in case of LVL, from the information where in the package the change was done, conclusion to the original class from in the lvl could be done

diff for original app and modified app

example code taken from an app which was inspected, modification happens for all at the same spot/manner

dex == smali, smali better readable but dex to see how easy change
since the translation from java to dex does some optimizations/logik, dex and java do not express the same, but it is how it is in the decompiled code, java is also an abstraction of the actual code, sometimes java also a little confusing since changes happened in dex code and cannot be decompiled to java in a good manner, very messy, it is included for better understanding anyways since humanreadable
\subsubsection{Pattern N1}
classes it attacks
\url{com/google/android/vending/licensing/LicenseValidator}
LicenseValidator, responsible for decrypting and verifying the response from the licensing server\cite{developersLicensingReference}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N1 pattern},
  label={lst:n1DiffDex}
]{data/n1.diff}

values are swapped

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-9},
  caption={Diff on Smali level for N1 pattern},
  label={lst:n1DiffSmali}
]{data/n1.diff}

switch case for input 0x01 (not licensed) and 0x02 (old license key) are swapped

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={11-15},
  caption={Diff on Java level for N1 pattern (abstracted)},
  label={lst:n1DiffJava}
]{data/n1.diff}
old code when license code not licensed return in case not licensed with error
after patching when not licensed return as old license key
\subsubsection{Pattern N2}
classes it attacks
\url{com/google/android/vending/licensing/LicenseValidator.java}
LicenseValidator, responsible for decrypting and verifying the response from the licensing server\cite{developersLicensingReference}
greift auch zB. google maps api (\url{com/google/android/gms/}) oder in app billing (\url{com/android/iab/v3/}) an, collateral schaden
one Pattern

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N2 pattern},
  label={lst:n2DiffDex}
]{data/n2.diff}

move-result is replaced by move const

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for n2 pattern},
  label={lst:n2DiffSmali}
]{data/n2.diff}

instead of moving the result from a function to v3, it is initiated with true/1

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N2 pattern (abstracted)},
  label={lst:n2DiffJava}
]{data/n2.diff}

old code: signature was verified, if true it is continued
after patching the verification is treated as always true and so it is continued
\subsubsection{Pattern N3}
classes it attacks
\url{com/google/android/vending/licensing/APKExpansionPolicy.java}
\url{com/google/android/vending/licensing/ServerManagedPolicy.java}
Policy integration of License Verification Library, those are the two examples offered by Google\cite{developersLicensingReference}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for N3 pattern},
  label={lst:n3DiffDex}
]{data/n3.diff}

for forward value 0x0 is switched with 0x1 and for inverse...inversed

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for N3 pattern},
  label={lst:n3DiffSmali}
]{data/n3.diff}

variable is initiated with opposite of what they were initiated before


\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={17-23},
  caption={Diff on Java level for N3 pattern (abstracted)},
  label={lst:n3DiffJava}
]{data/n3.diff}

old code variable is initiated false and true for inversed as basic return value
after patching the return is the opposite, meaning all true results are now false and all false are now true, meaning wrong input is declared as OK
\subsubsection{Pattern N4}
classes it attacks
\url{com/google/android/vending/licensing/LicenseChecker.java}
LicenseChecker, class that instatiates a license check\cite{developersLicensingReference}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N4 patch},
  label={lst:n4DiffDex}
]{data/n4.diff}

if-eqz is repalces by if-ne

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for N4 patch},
  label={lst:n4DiffSmali}
]{data/n4.diff}
in the original code variable v0 is compared for not equality with zero
after it is patched it is always compared with itself which returns always true and the condition is always called

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-12},
  caption={Diff on Java level for N4 patch (abstracted)},
  label={lst:n4DiffJava}
]{data/n4.diff}

in the original code it is checked whether the license is already cached, fi yes, condition is called
after patching the result of the check is always compared to itself, and thus  the condition is always called
\subsubsection{Pattern N5}
classes it attacks
\url{com/google/android/vending/licensing/LicenseValidator.java}

works the same way as pattern N2

im gegensatz zu N2 wird jetzt die condition nie aufgeraufen anstatt sie immer aufzurufen wie in N5
result is that the check for the result code given to the function and extracted from the server response is disabled since the result of the check is set to always false
\subsubsection{Pattern N6}
classes it attacks
\url{com/google/android/vending/licensing/LicenseValidator.java}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N6 patch},
  label={lst:n6DiffDex}
]{data/n6.diff}

if-eqz is replaced by move constant, variables for if-eq are changed

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-12},
  caption={Diff on Smali level for N6 patch},
  label={lst:n6DiffSmali}
]{data/n6.diff}

instead of testing for zero and then calling a condition, the to test variable is changed and the condition removed
the second equal check is done by comparing a variable with itself thus always true and the conidition is called

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={14-17},
  caption={Diff on Java level for N6 patch (abstracted)},
  label={lst:n6DiffJava}
]{data/n6.diff}

instead checking two variables for a case, the condition is just always called
\subsubsection{Pattern N7}
classes it attacks
\url{com/google/android/vending/licensing/ILicenseResultListener.java}
ILicenseResultListener, IPC callback implementation, receives async response from server\cite{developersLicensingReference}
einfach auf alles was in \url{com/android/} ist, some kind of bruteforce

similar to N2, but Java result is more generic

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={13-15},
  caption={Diff on Java level for N7 patch (abstracted)},
  label={lst:n7DiffJava}
]{data/n2.diff}

instead of initializing variable with result from function, it is always initialized with false / 0
\subsubsection{Amazon}
also applies pattern N2

classes it attacks, inside kiwi logic
\url{com/amazon/android/licensing/b.java}
\url{com/amazon/android/o/d.java}

see, obfuscated

similar like pattern N4

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for Amazon patch},
  label={lst:amazonDiffDex}
]{data/amazon.diff}

if-eqz is repalces by if-ne

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for Amazon patch},
  label={lst:amazonDiffSmali}
]{data/amazon.diff}
in the original code variable v0 is compared for not equality with zero
after it is patched it is always compared with itself which returns always true and the condition is always called

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-12},
  caption={Diff on Java level for Amazon patch (abstracted)},
  label={lst:amazonDiffJava}
]{data/amazon.diff}

in the original code the result from the server is tested whether it is "LICENSED"
after patching the response is always evalauted and the result is compared with itself which is always true

result
never the less what the check for "LICENSED" returns, the condition for "LICENSED" is always called
\subsubsection{Samsung Pattern}
also applies pattern N2

classes it attacks, inside zirconia logic
\url{com/samsung/zirconia/LicenseRetriever.java}
\url{com/samsung/zirconia/Zirconia.java}

not obfuscated

two patterns, lets call it S1 and S2, S1 used on both, S2 used twice on zirconia

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for Samsung patch},
  label={lst:samsungDiffDex}
]{data/samsung.diff}

S1
input for if-eq is modified
S2
move-result is replaced by move const

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for Samsung patch},
  label={lst:samsungDiffSmali}
]{data/samsung.diff}
S1
in the original code checks whether to different variables are equal
after patching the check is done with the same variables and thus always returns true

S3
in the original code the result of a function is moved to v0 and returned
after patching true/1 is always moved to v0 and returned

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={17-23},
  caption={Diff on Java level for Samsung patch (abstracted)},
  label={lst:samsungDiffJava}
]{data/samsung.diff}

\url{com/samsung/zirconia/LicenseRetriever.java}
always starts condition, even though input is not "12" as supposed to start
\url{com/samsung/zirconia/Zirconia.java}
S1
always returns true for checkLicenseFile and checkLicenseFilePhase2, does not check anything which is done normally
S2
always starts condition, even though input is not as supposed to start
\url{com/samsung/zirconia/Zirconia.java}
\begin{table}[h]
\centering
\begin{tabular}{l|cccccccc}
                           & \multicolumn{8}{c}{Patterns}           \\
\multicolumn{1}{c|}{Modus} & N1 & n3 & N3 & N3i & N4 & N5 & N6 & N7 \\ \hline
Auto                       & X  & X  & X  &     & X  &    &    &    \\
Auto (Inversed)            & X  & X  &    & X   & X  &    &    &    \\
Extreme                    &    &    &    &     &    & X  & X  & X  \\
Auto+Extreme               & X  & X  & X  &     & X  & X  & X  & X  \\
Auto (Inversed)+Extreme    & X  & X  &    & X   & X  & X  & X  &
\end{tabular}
\caption{Overview of License Verification Library patching patterns applied by each modus}
\label{table:patterns}
\end{table}



summarizing what patterns each modus applies Table~\ref{table:patterns}

auto: just applies minimum patches, N1 swaps switch cases so not licensed is treated here as old license key in the LicenseValidator, N2 skips the signature verification in the LicenseValidator, N3 inverts the return boolean for the policy checks in the implemented Policy class by initializing with 0/false, and N4 skips, in the only case occured in the test set, the check whether download is allowed and allows it always
auto inverse: does the same as auto but initializes the policy check with 1/true instead of false
extreme:
auto+extreme: applies auto and extreme patches
auto inverse+extreme: applies auto and extreme patches




!!! kann man das excel sheet in die datein machen und nicht als appendix, da manche apps ihre ergebnisse nicht öffentlich sehen wollen !!!
