\section{Patching Patterns} \label{section:luckypatcher-patterns}
In order to identify the structure of the single patterns, the code of the original code was compared to the cracked output.
The changes in the code were inspected on dex, smali and Java level with the tools explained in Section~\ref{section:reengineering}.
After analysing same patterns in the different modes it was identified that these patterns can be summed up as one.
\newline
The names of the patterns are taken from the patching result output in figure~\ref{fig:luckyScreen} on the right.
The number next to the pattern indicates how often it was applied to the application.
This number is not always correct.
The patterns N\textit{x} are used to circumvent the \gls{lvl} while the Amazon and Samsung patterns are tailored to do the same with the library of the respective store.
Additional knowledge on the patterns was was gained in the analysis.
\newline
Before explaining the patterns in detail, some information has to be provided.
When analyzing \gls{dex} files, instead of using hexadecimal values like \textit{0x0a}, a simplified presentation as \textit{0a} for improved overview in the diff files is chosen.
The opcodes used by the \gls{dvm} are taken from on of the documentations \cite{opcodes}.
When converting \gls{dex} files to smali files, the arguments of the opcodes are transfered to variables, e.g. \textit{x} in dex code is v\textit{x} in smali.
\newline
Since changing the dex code of an application results in a new checksum, the code has to be resigned as well.
This changes can be seen in the diff of the dex files.
They are not explicit mentioned in the analysis since it is no direct change of the attack.

\subsubsection{Patch Pattern N1}
Pattern N1 is present in all patching modes except the solo extreme mode.
It tagets the \textit{verify()} method of \textit{LicenseValidator} class in the \textit{com/google/android/vending/licensing/} folder.
This method is responsible for dectypting and verifying the response from the license server \cite{developersLicensingReference}.
\newline
In can be seen in the dex code in code snippet~\ref{codeSnippet:n1DiffDex} that the the blocks \textit{1a} and \textit{0f} are swapped in their order.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N1 pattern},
  label={codeSnippet:n1DiffDex}
]{data/n1.diff}
When looking at the smali code, the two blocks can be identified as cases of a switch statement.
Due to the internal mapping by the language, variables have different names.
The swap of switch cases \textit{0x1} und \textit{0x2} can be seen in the diff of code snippet~\ref{codeSnippet:n1DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-9},
  caption={Diff on Smali level for N1 pattern},
  label={codeSnippet:n1DiffSmali}
]{data/n1.diff}
In the Java code snippet~\ref{codeSnippet:n1DiffJava}, not only the syntactic but also semantic changes can be seen.
Before the patch, \textit{LICENSED} and \textit{LICENSED\_OLD\_KEY} both were handled as valid since \textit{LICENSED} jumps into the next case.
After the patch, \textit{NOT\_LICENSED} starts where \textit{LICENSED\_OLD\_KEY} started before.
Now, \textit{LICENSED} and \textit{NOT\_LICENSED} have the same behavior which means even though the response code is \textit{NOT\_LICENSED} it is valid.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={11-16},
  caption={Diff on Java level for N1 pattern (abstracted)},
  label={codeSnippet:n1DiffJava}
]{data/n1.diff}
The result is the voiding of the \textit{verify()} switch case since despite the input it always handles it as if the user is verified.
\subsubsection{Patch Pattern N2}
As well as pattern N1, N2 is applied in all patching modes, except the solo extreme mode.
It is more aggressive since it does not only attack the \gls{lvl} library, but extends it attacks to other Google Mobile Service libraries, located at \textit{com/google/android/gms/ads/}.
The extended analysis of different applications showed the altering of custom libraries, which include code for Google inapp billing, like AnjLab's inapp billing library \cite{inappBilling}, located at \textit{com/anjlab/android/iab/v3/Security}, in the FKUpdater, are modified as well.
This is collateral damage when applying the pattern to classes outside of the \gls{lvl} libary caused by the possibility of moving the classes of the library to different packages.
As long as the \gls{lvl} package is untouched, pattern N2, similar to pattern N1, attacks the \textit{LicenseValidator} class's \textit{verify()} method.
\newline
The changes in the \gls{dex} file in code snippet~\ref{codeSnippet:n2DiffDex} effect a simpler construct than pattern N1 does.
Instead of of using the opcode \textit{0a} for moving the result the result of the corresponding method to the variable 5 (source-destination order of \textit{05}), it simply moves (opcode \textit{12}) the value 1, which stands for true, to the variable 5 (\textit{15}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N2 pattern},
  label={codeSnippet:n2DiffDex}
]{data/n2.diff}

Smali displays this in a more convenient manner as seen in code snippet~\ref{codeSnippet:n2DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for n2 pattern},
  label={codeSnippet:n2DiffSmali}
]{data/n2.diff}

The impact on the Java code (see code snippet~\ref{codeSnippet:n2DiffJava}) is more complex.
Now, instead of calling additional code in case the signature is verified, the additional code is always called.
The reason for this structural change in code is the fact that in dex the if statement is split.
In a first step, the signature is verified , while in the second step the result is moved to a variable and this variable is evaluated in the third step.
Since the first step is not modified, it is still interpreted as a method by the decompiler.
For the second and third step it is different.
The reason is the decompiler since the variable is set with the constant value true and checked afterwards in an if evaluation.
In order to simplify and remove superfluous code, the if statement is collapsed and the body is moved to outer scope.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N2 pattern (abstracted)},
  label={codeSnippet:n2DiffJava}
]{data/n2.diff}

The conclusion is that after applying this pattern the result of the verification of the signature is no longer included in the logic of \textit{verify()}.

\subsubsection{Patch Pattern N3}
This pattern is different than the other patterns since there are two versions of it.
Pattern N3 is present when using auto mode while pattern N3i is used in the inversed auto mode.
The name N3i is chosen since it is used in the inversed auto mode.
LuckyPatcher does not make a difference between them.
They are combined under the same number since both attack the same logic inside the classes which define the policies.
In case of \textit{LicenseTest}
 application with the basic implementation of the \gls{lvl}, these classes are the \textit{APKExpansionPolicy} and \textit{ServerManagedPolicy} in the  \textit{com/google/android/vending/licensing/} folder.
Those two classes are examples of policies offered by Google \cite{developersLicensingReference} in which the \textit{allowAccess()} is altered.
\newline
The goal of the two patterns is the opposite of each other.
Both edit the value which is moved (opcode \textit{12}) into variable 1, but while N3 is moving true (opcode \textit{11}), N3i is moving false (opcode \textit{02}) (see code snippet~\ref{codeSnippet:n3DiffDex}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for N3 pattern},
  label={codeSnippet:n3DiffDex}
]{data/n3.diff}
As usual, the smali diff in code snippet~\ref{codeSnippet:n3DiffDex} delivers a better presentation of the two patterns.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for N3 pattern},
  label={codeSnippet:n3DiffSmali}
]{data/n3.diff}
The Java code in code snippet~\ref{codeSnippet:n3DiffJava} is, again, more complex since the structure if the code in the \gls{dex} files is different than the one in Java.
This is due to the fact that while in Java the \textit{return} followed by a value is possible, in \gls{dex} files this statement is split in two parts.
First, an internal variable is initialized with a standard value corresponding to the type of the return and in a second step the value is returned.
The patterns modify the value initialization which results in the change of the return statement in the Java code.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  float=h,
  frame=single,
  linerange={17-23},
  caption={Diff on Java level for N3 pattern (abstracted)},
  label={codeSnippet:n3DiffJava}
]{data/n3.diff}
Both patterns attack the class's \textit{allowAccess()} method which evaluates whether the verification result is according to the policy or not.
Since this method is a place to change the logic in order to fool a cracking tool by changing the desired outcome from true to false, Lucky Patcher offers a way to deal with this implementation.
This is the reason why the mode is called inverse auto mode since it fixes the return value to the opposite of the auto mode.


\subsubsection{Patch Pattern N4}
Pattern N4 was only applied once in the test sample and is part of the auto and auto inverse patching modes.
The target of the pattern is the \textit{LicenseChecker} class of the \gls{lvl} which is responsible for initializing the license check in it's \textit{checkAccess()} method \cite{developersLicensingReference}.
\newline
When the pattern is applied, it replaces the method's equal zero check (\textit{38}) with a check for not equal (\textit{33}) as it can be seen in code snippet~\ref{codeSnippet:n4DiffDex} and code snippet~\ref{codeSnippet:n4DiffSmali}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N4 patch},
  label={codeSnippet:n4DiffDex}
]{data/n4.diff}

\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for N4 patch},
  label={codeSnippet:n4DiffSmali}
]{data/n4.diff}
in the original code variable v0 is compared for not equality with zero
after it is patched it is always compared with itself which returns always true and the condition is always called

Since the code's syntax is changed when compiled from Java to dex, the decompiled code has a different sequence.
In the source code of the \gls{lvl}, the \textit{checkAccess()} first checks whether the policy allows acces.
When decompiled, it is checked for not equality first and the source code's equality block is moved to the else condition.
This results in the initial equals zero condition and latter not equal test.
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for N4 patch (abstracted)},
  label={codeSnippet:n4DiffJava}
]{data/n4.diff}


The result is that even though policy does not allow the access, this patterns modifies the \textit{checkAccess()} method to act as it would have been allowed anyway.


\subsubsection{Patch Pattern N5}
As part of the extreme mode, pattern N5 works on the \gls{dex} file similar to pattern N2 on the \textit{LicenseValidator}'s \textit{verify()} method. It does not affect the standard implementation of the \gls{lvl}.
\newline
As described before, the dex code is has a more complex decompiled Java code than the source code, especially in this case since instead of calling attributes of an object directly it stores them into variables before.
In this decompiled code, the parsing of the result code is spoofed and not the value of the response data is stored but the response code is set to 0.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-4},
  caption={Diff on Java level for N5 patch (abstracted)},
  label={codeSnippet:n5DiffJava}
]{data/n5.diff}

If this pattern would be applied alone, it would be able to circumvent the response code checks, but it is effective when combined with pattern N.


\subsubsection{Patch Pattern N6}
Pattern N6 is part of the extreme mode and attacks similar to the pattern N1, N2 and N5 the \textit{verify()} method in the \gls{lvl}'s '\textit{LivenseValidator} class.
\newline
The analysis of the \gls{dex} file in code snippet~\ref{codeSnippet:n6DiffDex} reveals that the attack replaces two statements.
The first modification is replacing the if equal zero (\textit{38}) with setting a constant (\textit{12}).
This results in the argument, that should have been checked for equality with zero, is now the target variable of the constant move 0 (\textit{0a}).
Since the \textit{if-eqz} opcode uses four touples, one of them is jump target which is set (\textit{06}), it has to be removed to keep the syntax of the dex code valid.
This is done by replacing the jump target with the \textit{nop} opcode (\textit{00}), which means no operation, and thus has no effect on the semantic of the code.
The second change is the modification of the follow up if statement.
Instead of checking whether the variable, which was originally checked for quality with zero, is equal (\textit{32}) to another variable (\textit{4a}), anoother variable is now compared to itself (\textit{00}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for N6 patch},
  label={codeSnippet:n6DiffDex}
]{data/n6.diff}
The change of the code structure is more visible in the code snipept~\ref{codeSnippet:n6DiffSmali}.
The \textit{if-eqz} is replaced by the initialization of the p2, a nop operation and an empty line while the follow up statement has its two different arguments each exchanged with the same variable.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-12},
  caption={Diff on Smali level for N6 patch},
  label={codeSnippet:n6DiffSmali}
]{data/n6.diff}

The analysis on Java level is more complex since removing the if statement destroys the original code herarchy and makes the syntax of the class invalid.
Decompilers are built to work on correct syntax, in more complex code processes, the reverse engineered code cannot be created.
In case of the \textit{LicenseTest}, the decompiler was not successful as well, but the reversed code revealed that in the \textit{verify()} method, right after the declaration of the variables, the second if statement of the two changed ones appeared
This can be seen in the first part of the code snippet~\ref{codeSnippet:n6DiffJava}.
The rest of the method cannot be decompiled and since translating from dex or smali to Java is hard to do by a human, this change cannot be analysed any further.
This is the reason to look interpretation of code which was achieved in one of the apps, in this context it is called \textit{IntelligentGadget} because the developer denied permission to name the application.
In this application, the code was fully restored and the change was reflected in simple way.
Instead of checking the response code whether it is not null (which cannot be seen in the code but is interpreted from the source code) and equal to the given value, it is checked whether it is not zero, which is not one of the specified values of the response code.
For this reason the check for invalidity of the response code is never true and thus the termination conidition is never called.
This simple reengineered code is the result of applying pattern N5 and pattern N6 in combination.
The changes of these two patterns add up to a clean Java code as seen in the second part of the code snippet~\ref{codeSnippet:n6DiffJava}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={14-16},
  caption={Diff on Java level for N6 patch (abstracted)},
  label={codeSnippet:n6DiffJava}
]{data/n6.diff}

In general this pattern is used to void the license code checks in the \textit{verify()} method.
\subsubsection{Patch Pattern N7}
The final pattern for the \gls{lvl} is pattern N7.
It is applied in the extreme mode and as this mode indicates, it takes a harsh approach of applying itself.
In addition to patching the \gls{lvl}'s \textit{ILicenseResultListener} \textit{onTransact()} method, which is the implementation fo the callback for interprocess communication which receives the async response from the license server \cite{developersLicensingReference}, it applies it's patterns to all classes possible in the \url{com/android/}.
It can be described as the bruteforce version of pattern N2 and thus should only applied in case the other modes are not successfully.
\newline
Similar to pattern N2, pattern N7 replaces the moving of the result (\textit{0a}) of a function to the variable with initializing it with a constant (\textit{12}).
Since \textit{move-result} moves it to variable v0 (\textit{00}) the resulting initialization sets v0 to zero.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={13-15},
  caption={Diff on Java level for N7 patch (abstracted)},
  label={codeSnippet:n7DiffJava}
]{data/n2.diff}
The aim of this attack is to patch the \textit{ILicenseResultListener} at any cost so \textit{onTransact()} returns true independet of the result of \textit{verifyLicense()} which is returned in the original implementation.

\subsubsection{Overview for Patching the \gls{lvl}}
The summary of the \gls{lvl} patterns and their use in the patching modes can be seen in table~\ref{table:patterns}.
The auto mode and inversed auto mode are applying patches at the important parts of the \gls{lvl}.
They are very efficient as long as the library is not altered.
In contrast to the determined patching of the automatic modes, the extreme mode applies pattern covering a variaty of methods.
This might cause instability, as seen in pattern N6, since it alters the syntax of the dex file.
\begin{table}[h]
\centering
\begin{tabular}{l|cccccccc}
                           & \multicolumn{8}{c}{Patterns}           \\
\multicolumn{1}{c|}{Modus} & N1 & N2 & N3 & N3i & N4 & N5 & N6 & N7 \\ \hline
Auto                       & X  & X  & X  &     & X  &    &    &    \\
Auto (Inversed)            & X  & X  &    & X   & X  &    &    &    \\
Extreme                    &    &    &    &     &    & X  & X  & X  \\
Auto+Extreme               & X  & X  & X  &     & X  & X  & X  & X  \\
Auto (Inversed)+Extreme    & X  & X  &    & X   & X  & X  & X  & X
\end{tabular}
\caption{Patching patterns applied by each mode}
\label{table:patterns}
\end{table}


\subsubsection{Amazon Market Patch}
Amazon does not have different pattern but only one patch which is called pattern in this context.
Since the Kiwi library is injected by Amazon and cannot be customized by the developer as well as the structure of the library result in the fact that only on pattern is sufficient to circumvent the license verification mechanism
The patch attacks two classes, one contained \textit{com/amazon/android/licensing/b.java} and the other one contained in \textit{com/amazon/android/o/d.java}.
Since the injected library is obfuscated no meaningful names can be presented.
\newline
The Amazon pattern works similar to the \gls{lvl}'s pattern N4 and replaces the if equal zero opcode (\textit{38}) with the opcode to check for not equality (\textit{33}).
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-3},
  caption={Diff on Dex level for Amazon patch},
  label={codeSnippet:amazonDiffDex}
]{data/amazon.diff}
In the original code, \textit{if-eqz} just takes the second 0 of the input (\textit{00}) for the comparison thus the first argument if the input is 0.
As the result of patching, the first argument is taken as well and thus v0 is compared to v0.
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={5-7},
  caption={Diff on Smali level for Amazon patch},
  label={codeSnippet:amazonDiffSmali}
]{data/amazon.diff}
The Java code makes it easier to reflect of the changes byattack.
Instead of checking in the \textit{b.java} class, whether the response code is \textit{LICENSED}, this statement of the if clause is always false and thus never called.
The same canges are applied to the \text{d.java} class but since the variables are obfuscated it is hard to describe the exact behavior.
After analysing the dependencies, it can be said that the function checks whether the given string is not null and then return true.
After patching, the result is always true since the null check is always false as in \textit{b.java}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-11},
  caption={Diff on Java level for Amazon patch (abstracted)},
  label={codeSnippet:amazonDiffJava}
]{data/amazon.diff}

The analysis of the Amazon patch indicates that there are less patterns needed since there is no altered behavior to expect.
Patches are applied to manipulate the checks in case the response code is null or different than \textit{LICENSED}.
The result is forced to be always true and thus the license verification always passes.


\subsubsection{Samsung Market Patch}
The Zirconia library of Samsung cannot be modified similar to Amazon and thus requires only one patch as well.
The patch is applied on the \textit{LicenseRetriever} and \textit{Zirconia} class in the \textit{com/samsung/zirconia} package.
Unlike Amazon's Kiwi \gls{drm}, Zirconia is not obfuscated and thus better to understand.
The Samsung patch uses two patterns, called S1 and S2 in order to distinguish between them.
While S1 is applied on both classes, S2 is applied twice but only on the \textit{Zirconia} class.
\newline
While Pattern S1 replaces the arguments of the \textit{if-eq} \textit{d6} with \textit{00} and instead of comparing two different variables, the variable is compared to itself, pattern S2 modifies the dex code to initialize a variable (\textit{12}) instead of assigning it the result of a method {\textit{0a}}.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={1-7},
  caption={Diff on Dex level for Samsung patch},
  label={codeSnippet:samsungDiffDex}
]{data/samsung.diff}
The result of this attack for pattern S1 is that the \textit{if-eq} statement is always true while the result of methods affected by pattern S2 is always true.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={9-15},
  caption={Diff on Smali level for Samsung patch},
  label={codeSnippet:samsungDiffSmali}
]{data/samsung.diff}
The abstract presentation of the result in Java code in code snippet~\ref{codeSnippet:samsungDiffJava} shows the resulting behavior.
This means for \textit{LicenseRetriever}'s \textit{receiveResponse} method, that instead of checking the repsone code for validity, it is always accepted as valid.
In the method \textit{checkerThreadWorker} of the \textit{Zirconia} class, the patch voids the check of the response code with the locally stored one.
These behavior is the result of pattern S1.
Pattern S2 works on the methods \textit{checkLicenseFile} and \textit{checkLicenseFilePhase2} of the \textit{Zirconia} class.
Instead to return the result of the license check, true always is returned.
\newline
\lstinputlisting[
  style=diff,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  frame=single,
  linerange={17-24},
  caption={Diff on Java level for Samsung patch (abstracted)},
  label={codeSnippet:samsungDiffJava}
]{data/samsung.diff}
The result of applying these patches is that not only the checks of the license files are voided and return always true but also reponse codes other than \textit{LICENSED} accepted since they are neither compared to the accepted one nor to the stored one, whcih should be valid.
