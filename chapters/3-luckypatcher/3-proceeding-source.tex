\section{Cracking License Verification} \label{section:luckypatcher-modi}
%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT



%
patterns und patching modes grob erklären (modi von luckypatcher die verschiedene operationen (pattern) auf app anwenden) => vorgehensweise zur\newline

see figure~\ref{fig:luckyScreen} middle liuckypatcher offeres different sets of methods to remove the license verification
Auto Mode - "The monomal number of patches. Suitable for most applications with simple protection" - uses patterns

Auto Mode (Inversed) - "There are a few differences from the ”Auto mode”. It may help you, if "Auto mode" was unsuccessful." - uses patterns

Other Patches (Extreme Mode!) - "Additional patches (mnay cause instability). Apply only if the other patterns were unsuccessful. Requires internet. Try to use together with ”Auto mode” or ”Auto mode (Inversed)”." - uses patterns

Auto Mode (Amazon Market) - "Removes License Verification for applciations from Amazon Market" - uses patterns

Auto Mode (SamsungApps) - "Removes License Verification for Apps from SamsungApps" - uses patterns  (is now GalaxyApps)


in order to find out what patterns are doing, different apps had to be analysed after patching
the apps chosen were already owned, in addition an app for each license verification model was created, uploaded and installed from the store so the license verification was working

to verify that license check is enabled, each app was extracted from the device using method described in \ref{subsection:tools-apk} and installed on a device with a different google account
then for each app a modified apk see figure~\ref{fig:luckyScreen} left, using one modus is created and copied to a computer for further inspection. so for each app there are 5 modified apks now


as example apps to show results Runtastic Pro\cite{runtasticApp}, Version 6.3, the created \textit{LicenseTest} and Teamspeak 3\cite{teamspeakApp}, Version 3.0.20.2, are chosen

\begin{table}[h]
\centering
\begin{tabular}{llll}
                                             & \multicolumn{3}{c}{Application}             \\
\multicolumn{1}{c|}{Modus}                   & LicenseTester & Runtastic Pro & Teamspeak 3 \\ \hline
\multicolumn{1}{l|}{Purchased}               & yes           & yes           & yes         \\
\multicolumn{1}{l|}{Pirated}                 & no            & no            & no          \\
\multicolumn{1}{l|}{Auto}                    & yes           & yes           & no          \\
\multicolumn{1}{l|}{Auto (Inversed)}         & no            & yes           & no          \\
\multicolumn{1}{l|}{Extreme}                 & no            & yes           & no          \\
\multicolumn{1}{l|}{Auto+Extreme}            & yes           & yes           & no          \\
\multicolumn{1}{l|}{Auto (Inversed)+Extreme} & no            & yes           & no
\end{tabular}
\caption{Functionality for the test apps before and after patching}
\label{table:functionality}
\end{table}

the result after patching the different apps with each modus returned the patterns used by each modus


\section{Code Manipulation} \label{section:luckypatcher-operation}
%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT

%
analysis done by looking at patched applications since luckypatcher has done a lot of obfuscation etc which makes it almost impossible to undertand (tools crash, junkbyte injection, only a few giant classes in java which do not make sense, some classes not decompiled since crash, dex/smali not very useful since no names etc), poor decompilation result
hard to analyze since of obfuscationa nd anti-decompilation measure

so look at cracked application in order to udnerstand how lucky aoptcher works
diff between code of unpatched and patched version of application which have lvl included
first it was tested with a simple app which was created and implemented lvl
also for apps from app store to see behaviour
diff tool to compare code base and see positions lucky patcher attacks

multiple tools used to reverse engineer the license verification circumvention by lucky patcher (see tools from reengineering)
first look at java code (higher representation, human readable), to understand what/where class/function have been modified
smali for having names for the bytecode executions
dex to see exactly how it was modified
document intended change by luckypatcher

luckypatcher works by patching dex (patching based not call intercept)

most patching options target googles lvl, but also available for amazon and samsung

information if lvl is contained can be pulled from manifest because of com.android.vending.CHECK\_LICENSE permission, only to show user and can circumvent anyway since solely for user to flag in market (ist das noch so?), trying to trick and not declare would break violate permissions and be stopped by andorid

luckypatcher extracts original classes.dex from apk and patches it
patching is doen on binary level and done by using different patterns which are dependent on the modus (see patterns/modi)
the result is either used to substitude the optimized classes.dex of attacked app with the patched .odex in dalvik cache (/data/dalvik-cache/), or can be output as an apk

works on most applications but has few problems on custom modified lvl libraries (liste der apps wo es funzt aus gdrive tabelle)

after applying patterns LP needs to update file header to reflect new checksum and hash values

\cite{munteanLicense}
%

wo arbeitet er?\newline
warum dex und nicht odex anschauen?\newline

Since the code is modified directly a static analysis is sufficient.\newline

UM ES EINFACHER ZU MACHEN, KEINE ODEX (WARUM), APK CREATEN UND AUF EINEM NORMALEN HANDY INSTALLIEREN(dann sieht man dass man die app wem anders gecracked geben kann - ringschluss blackmarket)\newline

after modification the dex is signed again in order to work on the phone (see installation und signature)

WIE IST MEIN VORGEHEN?
aufgrund dass odex datein device spezifisch sind und allgemeiner ansatz gesucht wird, wird die
app playstore -> modified APK erstellen -> analysieren
