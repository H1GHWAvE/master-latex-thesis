\section{Code Analysis} \label{section:luckypatcher-analysis}
The inspection of \gls{luckypatcherg}'s source code of version 6.0.4 was performed using the two decompilers DAD and JADX, which are described in subsection~\ref{subsection:reengineering-abstraction}.
The reverse engineered code was analysed using a text editor, like Atom \cite{atom}.
\newline
First, the folder structure was inspected by loading the reverse engineered code into the editor.
On the first look, different folders can be spotted in the applications tructure.
These folders contain the resources, different libraries and the actual \gls{luckypatcherg} code.
The folders containing code can be divided into four categories.
\begin{enumerate}
\item Android Support Library v4 with many of it's modules -
The library is used to provide downward compatibility of Android related functions.
\item Lucky Patcher -
Code containing the \gls{luckypatcherg} logic are located in two places.
Classes containing utility methods are stored in the package com.chelpus.
The application code itself can be found in the package
\textit{com.android.vending.billing.InApp- BillingService.LACK}.
It contains the activities and functions which are used for cracking applications.
\item The third category are support libraries required by Lucky Patcher to apply it's patches -
This includes libraries, e.g. axml \cite{axml} for serializing the AndroidManifest.xml from Android binary into an ASCII formatted, human readable xml and zip4j \cite{zip4j}, a Java library to handle ZIP files.
\item The fourth is a modified billing and license library -
It is applied in combination with a proxy to redirect inapp billing and licensing calls.
\end{enumerate}
In the resources folder, different predefined custom patches can be found.
\newline
\newline
\gls{luckypatcherg} tries to hide the way it works.
The developer uses heavy obfuscation and a flat code structure for the \gls{luckypatcherg} core logic.
The goal is to make reverse engineering as time consuming as possible.
These techniques are applied very effectively since \gls{luckypatcherg} itself is attacking such applications.
For this reason a blackbox approach is choosen.
This analysis focuses on gathering information from the output of a mechanism which should be analysed.
\gls{luckypatcherg}'s different modes are applied on a variety of applications. A lot of data and edge cases is generated this way to identify how \gls{luckypatcherg} works.
