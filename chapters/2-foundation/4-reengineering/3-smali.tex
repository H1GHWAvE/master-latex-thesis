\subsection{Smali Analysis} \label{subsection:tools-baksmali}
The smali presentation of the bytecode is the second abstraction layer.
Smali is used to disassemble the dex bytecode into human friendly mnemonics.
It makes it easier to interpret the result of the changes in the bytecode regarding functionality and location.
\newline
The disassembling from dex to smali format is done using \textit{baksmali} \cite{smali}.
Assembling and disassembling of dex and smali is possible without the loss information since they have a bijective mapping\cite{smali}.
It takes the \gls{apk} and disassembles \textit{classes.tex} file.
The output is a file for each class, containing the smali code.
The resulting syntax is loosely based on Jasmin's syntax
This process is done using the script in code snippet~\ref{codeSnippet:smaliScript}.
\newline
\lstinputlisting[
  float=h,
  breaklines=true,
  captionpos=b,
  frame=single,
  numbers=left,
  language=bash,
  linerange={19-21},
  firstnumber=1,
  caption={Script to generate the corresponding smali code for a given \gls{apk}},
  label={codeSnippet:smaliScript}
]{data/extractScript.sh}
An example of a smali view can be seen in code snippet~\ref{codeSnippet:smaliOuput}.
It is easier to understand than the dex presentation.
The advantage over the dex bytecode is that the structure of classes and methods is restored which makes it easier to analyse without additional tools.
In addition, the content of variables, as in line 3, can be identified without big effort.
Bytecode opcodes are replaced with their actual opcode name.
This enables the reader analyse the application's work flow similar to the source code.
\newline
\begin{lstlisting}[
  float=h,
  basicstyle=\footnotesize,
  breaklines=true,
  captionpos=b,
  frame=single,
  firstnumber=1,
  caption={smali code example},
  label={codeSnippet:smaliOutput}
]
# virtual methods
.method public magic()V
  const-string v4, "android_id"
  ...
  move-result v0
  if-eqz v0, :cond_7
  ...
.end method
\end{lstlisting}
