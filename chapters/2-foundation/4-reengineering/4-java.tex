\subsection{Java Analysis} \label{subsection:forensics-tools-java}
The third abstraction is the decompiled Java code.
The goal is to reverse engineer a result very close to the source code including the changes.
It suits best for the analysis since it contains the most information, such as variable and method names.
The representation is close to how the developer implemented the application.
\newline
As seen in figure~\ref{fig:re1}, the .dex files are isomorphic to the corresponding Java \gls{classg} files.
This makes it possible to decompile the dex bytecode into Java code.
The decompilation to the exact source code cannot be achieved since in the compilation process some information is lost.
Another problem is the otimization of the dex bytecode for mobile usage.
The specific mobile patterns are unknown to the Java decompiler.
The outcome is not always sufficient and for this reason two different decompilers, DAD and JADX, are used.
\newline
The first decompiler is DAD, short name of "DAD is A Decompiler".
It is part of Androguard \cite{androguard}.
It works with the dex bytecode and does not require third aprty tools like dex2jar \cite{dex2jar}.
Code snippet~\ref{codeSnippet:androguardScript} shows how it is used to decompile the \gls{apk} into Java code.
\newline
\lstinputlisting[
  float=h,
  breaklines=true,
  captionpos=b,
  frame=single,
  numbers=left,
  language=bash,
  linerange={7-9},
  firstnumber=1,
  caption={Script to decompile to Java using androguard},
  label={codeSnippet:androguardScript}
]{data/extractScript.sh}
The second decompiler is JADX \cite{jadx}.
It supports decompilation for dex to Java code.
It can be used in the command line as seen in Code snippet~\ref{codeSnippet:jadxScript}.
\lstinputlisting[
  float=h,
  breaklines=true,
  captionpos=b,
  frame=single,
  numbers=left,
  language=bash,
  linerange={28-30},
  firstnumber=1,
  caption={Script to decompile to Java using JADX},
  label={codeSnippet:jadxScript}
]{data/extractScript.sh}
