\subsection{Android Runtime} \label{subsection:android-art}
In Android version 4.4 "Kitkat" Google introduced \gls{art} which was optional and only available as a preview through the developer options.
Like \gls{dvm}, \gls{art} executes the \gls{dex} fileformat und \gls{dex} bytecode specification \cite{androidArt}.
With the release of verison 5.0 "Lollipop" \gls{art} it became the runtime of choice since \gls{dvm} had some major flaws.
Throughout the Android 6.0 "Marshmallow" previews it was constantly evolving and sometimes breaking with older versions at the cost of almost no documentation.
\newline
\gls{art} is designed to address the shortcomings of the \gls{dvm}.
Maintaining an \gls{vm} is expensive, having an interpreter and \gls{jit} is not as efficient of native code and doing \gls{jit} each time the application is executed is wasteful.
This and maintaining background threads require significantly more CPU cycles which can be directly translated to slower performance and increased battery usage.
In addition the Dalvik \gls{gc} frequently causes hands and jitters and \gls{dvm} is only supporting 32bit.
With \gls{art} Android is following iOS into the 64bit world but this is not the only advantage over the \gls{dvm}.
Improvements in the \gls{vm} make the maintenance less expensive and the compilation is changed from \gls{jit} to \gls{aot} as well as the overhead cycles have been reduced.
The \gls{gc} is also non-blocking now and and can run parallel in fore- and background.
\newline
The mean idea of \gls{art} and \gls{aot} is to compile the application to one of two types, either native code or \gls{llvm} code.
Each of the types has its purpose and advantage.
The native code offers an improved execution performance while the \gls{llvm} code offers protability.
In practice the preference is to compile to native since adding \gls{llvm} bitcode adds another layer of complexity to \gls{art}.
\newline
Different from \gls{dvm} is the fact that \gls{art} uses not one but two file formats.
Similar to the zygote of \gls{dvm}, \gls{art} offers an image of pre-initialized classes and and related object at run time, the boot.art file.
It is mapped to the memory upon zygote startup to provide improved application starting time \cite{developersConfigureArt}.
The second file format is



Art itself:
art uses not one but two file formats
art - only one file, boot.art, in /syste/framework/architecture (arm,...)
oat - master file, boot.oat, in /syste/framework/architecture (arm,...) - odex files no longer optimized dex but oat, alongeside apk for system apps/frameworks, /data/dalvik-cache for 3rd party apps, still uses odex extension, now file format is elf/oat\newline
art files is a proprietary format, poorly documented, changed format internally repeatedly
art file maps in memory right before oat, which links with it
contains pre-initilited classes, objects and support structures\newline
ART/OAT files are created (on device or on host) by dex2oat
art still optimizes dex but uses dex2oat instead, odex files are actually oat files (elf shared objects WAS IST DAS), actual dex payload buried deep inside
command line saved inside oat file's key value store
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{data/oat.png}
    \caption{oat}
    \label{fig:oat}
\end{figure}
\newline

art file format
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{data/art.png}
    \caption{art}
    \label{fig:art}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{data/art2.png}
    \caption{art2}
    \label{fig:art2}
\end{figure}

art code generation
oat method headers point to offset of native code
each method has a quick or portable method header, contains mapping from virtual register to underlying machine registers
each method has a quick or protable frame info, provides frame size in bytes, core register spill mask, fp register spill mask
generated code uses unusual registers, especially fond of using lr as call register, still saves/restores registers so as not to violate arm conventions
\newline

art supports mutliple architectures(x86,arm/64,mips)
compiler is layered architecture, using portable (llvm) adds another lvl with llvm bitcode (not in this scope)
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{data/artarch.png}
    \caption{artarch}
    \label{fig:artarch}
\end{figure}

the oat dexfile header
oat headers are 1...n dex files, actual value given by dexfilecount field in header
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{data/oatdex.png}
    \caption{oatdex}
    \label{fig:awesome_image122223}
\end{figure}


finding dex in oat
odex files will usually have only one (=original) dex embedded
booat.oat is something else entirely, some 14 dex files the best of the android framework jars, each dex contains potentilly hundres of classes



lessons
base code is dex so vm is still 32bit, no 64bit registers or operands so mapping to underlying arch inst always 64bit, there are actually a frw 64bit instructions but most dex code doesnt use them
generated code isnt always that efficient, not on same par as an optimizing antive code compiler, likely to improve with llvm optimizations
overall code (determined by Mir optimizations) flow is same
garbage collection, register maps, likewase same
cavears: not all methods guaranteed to be compiled, reversing can be quite a pain
\newline


isn't android all dalvik now?
art is runtime but application compile into dex, art is compiled on device during install, art binaries has dalvik embedded, some methods may be left as dex to be interpreted, dalvik is much easier to debug than art --see- evaluation \newline
\cite{andevconDalvikART}
%

+

%ART runtime threads
%the daemon threads are started in java by libcore, daemon class wraps thread class and provides singleton INSTANCE, do same basic operations as they did in "classic" dalvikVM, libart subree in libcore implementation slightly different
%\newline
