\subsection{Packers}
\label{subsection:counter-reengineering-propack}
%START TEXT INPUT
This is my real text! Rest might be copied or not be checked!
%START TEXT INPUT

%
goal of packers it to protect the code from modifications or attacks, good or bad nature, often used by malware as well\cite{packersMalware}

launch stub application which unpacks and/or decrypts zipped code
works at runtime, the 'outer' stub application unpacks content of 'inner' executable into memory and executes, example for x86 platform, UPX \cite{sourceforgeUpx}, since works at runtime hidden from static analysis

%
dynamic code loading
best would be an application is transformed by obfuscator that it does not contain any meta information or directly interpretable bytecode, not possible because DVM would not be able to read -see- packing, often used in malware \cite{packerProblemSolution}\newline
packer transforms code that a reverse engineer cannot directly extract information, e.g. by encrypting programm data no information can be extracted without decrypting, would be bad for programm as well that is why packer uses loader stub to decrypt in runtime, soultion decrypt by hand or dynamic analysis\newline
in general two components are created, loader stub and encrypted app, on android the encrypted dex file, easier to create as the loader stub\newline
BILD WIE ER FUNKTIONIERT
step 1 load encrypted app into memory (download from server, extract from data structure, plain file available)
step 2 app file is decrypted -see- original dex, can be any encryption from simple to hard, speed may slow down
step 3 load decrypted dex into DVM from a bytearray, see \cite{schulzLabCourse}
step 4 execute\newline
\cite{blackhatPackers}\cite{yuPackers}


\cite{schulzLabCourse} stellt hier basic version vor, bessere versionen ist das im folgenden

result: protection makes it hard to analyze the target application, because its bytecode is only available encrypted, decrypted version the unpacking stub has to be analyzed, great slow down, other obfuscations can be applied on stub
%

%
program delivered to end user should be transformed, no direct link between it and original source code, attackers cannot reengineer code and find vulnerability

\cite{munteanLicense}
\newline
\newline
\textbf{HoseDex2Jar} \newline
HoseDex2Jar is a prototype/proof of concept of a service which obfuscates, mangles and mungs APK files
goal it to prevent easy decompilation and thus analysis

original dex file is packed into a compressed container, encrypted and injects into the dalvik header, dexception\cite{safedexSlides}, easy to spot since dex header is not normal
static analysis will not work since encrypted file will be ignored, which contents the actual code

on execution loader stub decrypts the dex file in memory and dumps to file system
loader stub acts as proxy and passes events to the dex file on system using a dexClassLoader
since the stub is added slight file size increase, but no big impact
not available for real use, website taken down
further developed projects are bangcle or IJIAMI, often for malware\cite{packersMalware}\cite{yuPackers}

\cite{area41}\cite{githubDehoser}\cite{strazzareLevel0}
\newline
\newline
\textbf{ApkProtect} \newline
also known as dexcrypt, appears to be active but no website, there might be clones
slightly different than a packer, stub fixes broken code which is normally not translated by tools and makes it as it should be
features anti-debug, anti-decompile, almost like a packer, string encryption


tool mangles code original code
-modifies entrypoint to loader stub
-prevents static analysis
on intall dalvik optimizes the dex file into memory ignoring bad parts\newline

when executed the 'original' dalvik code is executed, during runtime loader stub from the 'original' code fixes the odex in memory, then it is executed as normal
results in slight file size increase and prevents easily static analysis

still has string encryption (like DexGuard, Allatori) afterwards
\cite{strazzareLevel0}\cite{blackhatPackers}\cite{yuPackers}





%MAILVERKEHR
relevant fuer eure beiden Thema ist sicherlich, dass die neuen Androidversionen keinen dynamischen Code mehr unterstuetzen (soweit mir bekannt) bzw. das dieser zuvor in einer Datei abgelegt werden muss (vgl. OpenDexfile(...)). Hat jemand von euch den aktuellen Android Code gerade parat? Ich habe ihn hier auf meinem NB nicht drauf.
vgl. hierzu
\url{https://www.blackhat.com/docs/asia-15/materials/asia-15-Park-We-Can-Still-Crack-You-General-Unpacking-Method-For-Android-Packer-No-Root.pdf}

... Interessant waere, ob es noch irgendeine Moeglichkeit gibt doch dynamischen Code zu laden. Eine erste Idee war mit mkfifo fuer einen kurzen Zeitraum eine Datei zu liefern und dann wieder nur nonsense. Braucht Android die Datei nur kurzzeitig oder dauerhaft? Theoretisch bauen auf der Idee von dynamischen Code zahlreiche sicherheitsloesungen auf. Weiss jemand von euch bereits, warum Google das entfernt hat? Malware Problem?
